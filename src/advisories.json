[
  {
    "id": "PSF-2007-1",
    "cve": "CVE-2007-4965",
    "published": "2007-09-18T22:00:00+00:00",
    "modified": "2018-10-15T20:57:01+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue1179",
      "issue_number": "1179"
    },
    "details": "Multiple integer overflows in the imageop module in Python 2.5.1 and earlier allow context-dependent attackers to cause a denial of service (application crash) and possibly obtain sensitive information (memory contents) via crafted arguments to (1) the tovideo method, and unspecified other vectors related to (2) imageop.c, (3) rbgimgmodule.c, and other files, which trigger heap-based buffer overflows.",
    "affected_versions": [
      [
        [
          2,
          3,
          1
        ],
        [
          2,
          3,
          6
        ]
      ],
      [
        [
          2,
          4,
          1
        ],
        [
          2,
          4,
          4
        ]
      ],
      [
        [
          2,
          5,
          1
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          5,
          3
        ],
        "commits": [
          "4df1b6d478020ac51c84467f47e42083f53adbad"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        3
      ],
      [
        2,
        4
      ]
    ]
  },
  {
    "id": "PSF-2007-2",
    "cve": "CVE-2007-4559",
    "published": "2007-08-28T00:00:00+00:00",
    "modified": "2023-09-18T22:37:04+00:00",
    "severity": null,
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/102950",
      "issue_number": "102950"
    },
    "details": "Directory traversal vulnerability in the (1) extract and (2) extractall functions in the tarfile module in Python allows user-assisted remote attackers to overwrite arbitrary files via a .. (dot dot) sequence in filenames in a TAR archive, a related issue to CVE-2001-1267.",
    "affected_versions": [
      [
        [
          2,
          3,
          1
        ],
        [
          2,
          3,
          6
        ]
      ],
      [
        [
          2,
          4,
          1
        ],
        [
          2,
          4,
          4
        ]
      ],
      [
        [
          2,
          5,
          1
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          8,
          17
        ],
        "commits": [
          "79e63e528795c700a8bd198c15f3322ee25ea786"
        ]
      },
      {
        "version": [
          3,
          9,
          17
        ],
        "commits": [
          "98016f7c92aa4c1232c68bac1ed6646db31782ec"
        ]
      },
      {
        "version": [
          3,
          10,
          12
        ],
        "commits": [
          "425065bb002b9cbf9c12f61a6f3102f2ce2b8d14"
        ]
      },
      {
        "version": [
          3,
          12,
          0
        ],
        "commits": [
          "af530469954e8ad49f1e071ef31c844b9bfda414"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        3
      ],
      [
        2,
        4
      ],
      [
        2,
        5
      ]
    ]
  },
  {
    "id": "PSF-2008-1",
    "cve": "CVE-2008-1679",
    "published": "2008-04-21T20:00:00+00:00",
    "modified": "2017-09-28T12:57:01+00:00",
    "severity": null,
    "issue": null,
    "details": "Multiple integer overflows in imageop.c in Python before 2.5.3 allow context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via crafted images that trigger heap-based buffer overflows.  NOTE: this issue is due to an incomplete fix for CVE-2007-4965.",
    "affected_versions": [
      [
        [
          2,
          4,
          1
        ],
        [
          2,
          4,
          5
        ]
      ],
      [
        [
          2,
          5,
          1
        ],
        [
          2,
          5,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          6,
          1
        ],
        "commits": [
          "e7d8be80ba634fa15ece6f503c33592e0d333361"
        ]
      },
      {
        "version": [
          2,
          7,
          1
        ],
        "commits": [
          "3ce5d9207e66d61d4b0502cf47ed2d2bcdd2212f"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        4
      ],
      [
        2,
        5
      ]
    ]
  },
  {
    "id": "PSF-2008-2",
    "cve": "CVE-2008-1721",
    "published": "2008-04-10T19:00:00+00:00",
    "modified": "2018-10-11T19:57:01+00:00",
    "severity": null,
    "issue": null,
    "details": "Integer signedness error in the zlib extension module in Python 2.5.2 and earlier allows remote attackers to execute arbitrary code via a negative signed integer, which triggers insufficient memory allocation and a buffer overflow.",
    "affected_versions": [
      [
        [
          2,
          4,
          1
        ],
        [
          2,
          4,
          5
        ]
      ],
      [
        [
          2,
          5,
          1
        ],
        [
          2,
          5,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          6,
          1
        ],
        "commits": [
          "e7d8be80ba634fa15ece6f503c33592e0d333361"
        ]
      },
      {
        "version": [
          2,
          7,
          1
        ],
        "commits": [
          "3ce5d9207e66d61d4b0502cf47ed2d2bcdd2212f"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        4
      ],
      [
        2,
        5
      ]
    ]
  },
  {
    "id": "PSF-2008-3",
    "cve": "CVE-2008-1887",
    "published": "2008-04-18T17:00:00+00:00",
    "modified": "2018-10-11T19:57:01+00:00",
    "severity": null,
    "issue": null,
    "details": "Python 2.5.2 and earlier allows context-dependent attackers to execute arbitrary code via multiple vectors that cause a negative size value to be provided to the PyString_FromStringAndSize function, which allocates less memory than expected when assert() is disabled and triggers a buffer overflow.",
    "affected_versions": [
      [
        [
          2,
          4,
          1
        ],
        [
          2,
          4,
          5
        ]
      ],
      [
        [
          2,
          5,
          1
        ],
        [
          2,
          5,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          6,
          1
        ],
        "commits": [
          "e7d8be80ba634fa15ece6f503c33592e0d333361"
        ]
      },
      {
        "version": [
          2,
          7,
          1
        ],
        "commits": [
          "3ce5d9207e66d61d4b0502cf47ed2d2bcdd2212f"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        4
      ],
      [
        2,
        5
      ]
    ]
  },
  {
    "id": "PSF-2008-4",
    "cve": "CVE-2008-2315",
    "published": "2008-08-01T14:00:00+00:00",
    "modified": "2018-10-11T19:57:01+00:00",
    "severity": null,
    "issue": null,
    "details": "Multiple integer overflows in Python 2.5.2 and earlier allow context-dependent attackers to have an unknown impact via vectors related to the (1) stringobject, (2) unicodeobject, (3) bufferobject, (4) longobject, (5) tupleobject, (6) stropmodule, (7) gcmodule, and (8) mmapmodule modules.  NOTE: The expandtabs integer overflows in stringobject and unicodeobject in 2.5.2 are covered by CVE-2008-5031.",
    "affected_versions": [
      [
        [
          2,
          4,
          1
        ],
        [
          2,
          4,
          5
        ]
      ],
      [
        [
          2,
          5,
          1
        ],
        [
          2,
          5,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          6,
          1
        ],
        "commits": [
          "e7d8be80ba634fa15ece6f503c33592e0d333361"
        ]
      },
      {
        "version": [
          2,
          7,
          1
        ],
        "commits": [
          "3ce5d9207e66d61d4b0502cf47ed2d2bcdd2212f"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        4
      ],
      [
        2,
        5
      ]
    ]
  },
  {
    "id": "PSF-2008-5",
    "cve": "CVE-2008-2316",
    "published": "2008-08-01T14:00:00+00:00",
    "modified": "2018-10-11T19:57:01+00:00",
    "severity": null,
    "issue": null,
    "details": "Integer overflow in _hashopenssl.c in the hashlib module in Python 2.5.2 and earlier might allow context-dependent attackers to defeat cryptographic digests, related to \"partial hashlib hashing of data exceeding 4GB.\"",
    "affected_versions": [
      [
        [
          2,
          4,
          1
        ],
        [
          2,
          4,
          5
        ]
      ],
      [
        [
          2,
          5,
          1
        ],
        [
          2,
          5,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          6,
          1
        ],
        "commits": [
          "e7d8be80ba634fa15ece6f503c33592e0d333361"
        ]
      },
      {
        "version": [
          2,
          7,
          1
        ],
        "commits": [
          "3ce5d9207e66d61d4b0502cf47ed2d2bcdd2212f"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        4
      ],
      [
        2,
        5
      ]
    ]
  },
  {
    "id": "PSF-2008-6",
    "cve": "CVE-2008-3142",
    "published": "2008-08-01T14:00:00+00:00",
    "modified": "2018-10-11T19:57:01+00:00",
    "severity": null,
    "issue": null,
    "details": "Multiple buffer overflows in Python 2.5.2 and earlier on 32bit platforms allow context-dependent attackers to cause a denial of service (crash) or have unspecified other impact via a long string that leads to incorrect memory allocation during Unicode string processing, related to the unicode_resize function and the PyMem_RESIZE macro.",
    "affected_versions": [
      [
        [
          2,
          4,
          1
        ],
        [
          2,
          4,
          5
        ]
      ],
      [
        [
          2,
          5,
          1
        ],
        [
          2,
          5,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          6,
          1
        ],
        "commits": [
          "e7d8be80ba634fa15ece6f503c33592e0d333361"
        ]
      },
      {
        "version": [
          2,
          7,
          1
        ],
        "commits": [
          "3ce5d9207e66d61d4b0502cf47ed2d2bcdd2212f"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        4
      ],
      [
        2,
        5
      ]
    ]
  },
  {
    "id": "PSF-2008-7",
    "cve": "CVE-2008-3143",
    "published": "2008-08-01T14:00:00+00:00",
    "modified": "2018-10-11T19:57:01+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue2620",
      "issue_number": "2620"
    },
    "details": "Multiple integer overflows in Python before 2.5.2 might allow context-dependent attackers to have an unknown impact via vectors related to (1) Include/pymem.h; (2) _csv.c, (3) _struct.c, (4) arraymodule.c, (5) audioop.c, (6) binascii.c, (7) cPickle.c, (8) cStringIO.c, (9) cjkcodecs/multibytecodec.c, (10) datetimemodule.c, (11) md5.c, (12) rgbimgmodule.c, and (13) stropmodule.c in Modules/; (14) bufferobject.c, (15) listobject.c, and (16) obmalloc.c in Objects/; (17) Parser/node.c; and (18) asdl.c, (19) ast.c, (20) bltinmodule.c, and (21) compile.c in Python/, as addressed by \"checks for integer overflows, contributed by Google.\"",
    "affected_versions": [
      [
        [
          2,
          4,
          1
        ],
        [
          2,
          4,
          5
        ]
      ],
      [
        [
          2,
          5,
          1
        ],
        [
          2,
          5,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          5,
          3
        ],
        "commits": [
          "83ac0144fa3041556aa4f3952ebd979e0189a19c"
        ]
      },
      {
        "version": [
          2,
          7,
          1
        ],
        "commits": [
          "d492ad80c872d264ed46bec71e31a00f174ac819"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        4
      ]
    ]
  },
  {
    "id": "PSF-2008-8",
    "cve": "CVE-2008-3144",
    "published": "2008-08-01T14:00:00+00:00",
    "modified": "2018-10-11T19:57:01+00:00",
    "severity": null,
    "issue": null,
    "details": "Multiple integer overflows in the PyOS_vsnprintf function in Python/mysnprintf.c in Python 2.5.2 and earlier allow context-dependent attackers to cause a denial of service (memory corruption) or have unspecified other impact via crafted input to string formatting operations.  NOTE: the handling of certain integer values is also affected by related integer underflows and an off-by-one error.",
    "affected_versions": [
      [
        [
          2,
          4,
          1
        ],
        [
          2,
          4,
          5
        ]
      ],
      [
        [
          2,
          5,
          1
        ],
        [
          2,
          5,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          6,
          1
        ],
        "commits": [
          "e7d8be80ba634fa15ece6f503c33592e0d333361"
        ]
      },
      {
        "version": [
          2,
          7,
          1
        ],
        "commits": [
          "3ce5d9207e66d61d4b0502cf47ed2d2bcdd2212f"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        4
      ],
      [
        2,
        5
      ]
    ]
  },
  {
    "id": "PSF-2008-9",
    "cve": "CVE-2008-4864",
    "published": "2008-10-31T22:00:00+00:00",
    "modified": "2018-10-11T19:57:01+00:00",
    "severity": null,
    "issue": null,
    "details": "Multiple integer overflows in imageop.c in the imageop module in Python 1.5.2 through 2.5.1 allow context-dependent attackers to break out of the Python VM and execute arbitrary code via large integer values in certain arguments to the crop function, leading to a buffer overflow, a different vulnerability than CVE-2007-4965 and CVE-2008-1679.",
    "affected_versions": [
      [
        [
          2,
          4,
          1
        ],
        [
          2,
          4,
          5
        ]
      ],
      [
        [
          2,
          5,
          1
        ],
        [
          2,
          5,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          6,
          1
        ],
        "commits": [
          "e7d8be80ba634fa15ece6f503c33592e0d333361"
        ]
      },
      {
        "version": [
          2,
          7,
          1
        ],
        "commits": [
          "3ce5d9207e66d61d4b0502cf47ed2d2bcdd2212f"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        4
      ],
      [
        2,
        5
      ]
    ]
  },
  {
    "id": "PSF-2008-10",
    "cve": "CVE-2008-5031",
    "published": "2008-11-10T16:00:00+00:00",
    "modified": "2018-10-11T19:57:01+00:00",
    "severity": null,
    "issue": null,
    "details": "Multiple integer overflows in Python 2.2.3 through 2.5.1, and 2.6, allow context-dependent attackers to have an unknown impact via a large integer value in the tabsize argument to the expandtabs method, as implemented by (1) the string_expandtabs function in Objects/stringobject.c and (2) the unicode_expandtabs function in Objects/unicodeobject.c.  NOTE: this vulnerability reportedly exists because of an incomplete fix for CVE-2008-2315.",
    "affected_versions": [
      [
        [
          2,
          4,
          1
        ],
        [
          2,
          4,
          5
        ]
      ],
      [
        [
          2,
          5,
          1
        ],
        [
          2,
          5,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          5,
          3
        ],
        "commits": [
          "44a93e54f4b0f90634d16d53c437fabb6946ea9d"
        ]
      },
      {
        "version": [
          2,
          7,
          1
        ],
        "commits": [
          "dd15f6c315f20c1a9a540dd757cd63e27dbe9f3c"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        4
      ]
    ]
  },
  {
    "id": "PSF-2010-1",
    "cve": "CVE-2009-4134",
    "published": "2010-05-27T19:00:00+00:00",
    "modified": "2010-11-18T10:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue1179",
      "issue_number": "1179"
    },
    "details": "Buffer underflow in the rgbimg module in Python 2.5 allows remote attackers to cause a denial of service (application crash) via a large ZSIZE value in a black-and-white (aka B/W) RGB image that triggers an invalid pointer dereference.",
    "affected_versions": [
      [
        [
          2,
          5,
          1
        ],
        [
          2,
          5,
          2
        ]
      ],
      [
        [
          3,
          1,
          1
        ],
        [
          3,
          1,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          5,
          3
        ],
        "commits": [
          "4df1b6d478020ac51c84467f47e42083f53adbad"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        1
      ]
    ]
  },
  {
    "id": "PSF-2010-2",
    "cve": "CVE-2010-1449",
    "published": "2010-05-27T19:00:00+00:00",
    "modified": "2010-11-18T10:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue1179",
      "issue_number": "1179"
    },
    "details": "Integer overflow in rgbimgmodule.c in the rgbimg module in Python 2.5 allows remote attackers to have an unspecified impact via a large image that triggers a buffer overflow.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2008-3143.12.",
    "affected_versions": [
      [
        [
          2,
          5,
          1
        ],
        [
          2,
          5,
          2
        ]
      ],
      [
        [
          3,
          1,
          1
        ],
        [
          3,
          1,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          5,
          3
        ],
        "commits": [
          "4df1b6d478020ac51c84467f47e42083f53adbad"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        1
      ]
    ]
  },
  {
    "id": "PSF-2010-3",
    "cve": "CVE-2010-1450",
    "published": "2010-05-27T19:00:00+00:00",
    "modified": "2010-11-18T10:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue1179",
      "issue_number": "1179"
    },
    "details": "Multiple buffer overflows in the RLE decoder in the rgbimg module in Python 2.5 allow remote attackers to have an unspecified impact via an image file containing crafted data that triggers improper processing within the (1) longimagedata or (2) expandrow function.",
    "affected_versions": [
      [
        [
          2,
          5,
          1
        ],
        [
          2,
          5,
          2
        ]
      ],
      [
        [
          3,
          1,
          1
        ],
        [
          3,
          1,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          5,
          3
        ],
        "commits": [
          "4df1b6d478020ac51c84467f47e42083f53adbad"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        1
      ]
    ]
  },
  {
    "id": "PSF-2010-4",
    "cve": "CVE-2010-1634",
    "published": "2010-05-27T19:00:00+00:00",
    "modified": "2010-06-17T09:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue8674",
      "issue_number": "8674"
    },
    "details": "Multiple integer overflows in audioop.c in the audioop module in Python 2.6, 2.7, 3.1, and 3.2 allow context-dependent attackers to cause a denial of service (application crash) via a large fragment, as demonstrated by a call to audioop.lin2lin with a long string in the first argument, leading to a buffer overflow.  NOTE: this vulnerability exists because of an incorrect fix for CVE-2008-3143.5.",
    "affected_versions": [
      [
        [
          2,
          5,
          1
        ],
        [
          2,
          5,
          5
        ]
      ],
      [
        [
          2,
          6,
          1
        ],
        [
          2,
          6,
          5
        ]
      ],
      [
        [
          3,
          1,
          1
        ],
        [
          3,
          1,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          6,
          6
        ],
        "commits": [
          "7ceb497ae6f554274399bd9916ea5a21de443208"
        ]
      },
      {
        "version": [
          2,
          7,
          1
        ],
        "commits": [
          "ee289e6cd5c009e641ee970cfc67996d8f871221"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        5
      ],
      [
        3,
        1
      ]
    ]
  },
  {
    "id": "PSF-2010-5",
    "cve": "CVE-2010-2089",
    "published": "2010-05-27T19:00:00+00:00",
    "modified": "2010-06-17T09:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue7673",
      "issue_number": "7673"
    },
    "details": "The audioop module in Python 2.7 and 3.2 does not verify the relationships between size arguments and byte string lengths, which allows context-dependent attackers to cause a denial of service (memory corruption and application crash) via crafted arguments, as demonstrated by a call to audioop.reverse with a one-byte string, a different vulnerability than CVE-2010-1634.",
    "affected_versions": [
      [
        [
          2,
          5,
          1
        ],
        [
          2,
          5,
          5
        ]
      ],
      [
        [
          2,
          6,
          1
        ],
        [
          2,
          6,
          5
        ]
      ],
      [
        [
          3,
          1,
          1
        ],
        [
          3,
          1,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          6,
          6
        ],
        "commits": [
          "e9123efa21a16584758b5ce7da93d3966cf0cd81"
        ]
      },
      {
        "version": [
          2,
          7,
          1
        ],
        "commits": [
          "8e42fb7ada3198e66d3f060c5c87c52465a86e36"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        5
      ],
      [
        3,
        1
      ]
    ]
  },
  {
    "id": "PSF-2010-6",
    "cve": "CVE-2010-3492",
    "published": "2010-10-19T19:00:00+00:00",
    "modified": "2017-09-18T12:57:01+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue6706",
      "issue_number": "6706"
    },
    "details": "The asyncore module in Python before 3.2 does not properly handle unsuccessful calls to the accept function, and does not have accompanying documentation describing how daemon applications should handle unsuccessful calls to the accept function, which makes it easier for remote attackers to conduct denial of service attacks that terminate these applications via network connections.",
    "affected_versions": [
      [
        [
          2,
          5,
          1
        ],
        [
          2,
          5,
          5
        ]
      ],
      [
        [
          2,
          6,
          1
        ],
        [
          2,
          6,
          6
        ]
      ],
      [
        [
          3,
          1,
          1
        ],
        [
          3,
          1,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          1
        ],
        "commits": [
          "19e9fefc660d623ce7c31fb008cde1157ae12aba",
          "5ea3d0f95b51009fa1c3409e7dd1c12006427ccc"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        5
      ],
      [
        2,
        6
      ],
      [
        3,
        1
      ]
    ]
  },
  {
    "id": "PSF-2010-7",
    "cve": "CVE-2010-3493",
    "published": "2010-10-19T19:00:00+00:00",
    "modified": "2017-09-18T12:57:01+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue6706",
      "issue_number": "6706"
    },
    "details": "Multiple race conditions in smtpd.py in the smtpd module in Python 2.6, 2.7, 3.1, and 3.2 alpha allow remote attackers to cause a denial of service (daemon outage) by establishing and then immediately closing a TCP connection, leading to the accept function having an unexpected return value of None, an unexpected value of None for the address, or an ECONNABORTED, EAGAIN, or EWOULDBLOCK error, or the getpeername function having an ENOTCONN error, a related issue to CVE-2010-3492.",
    "affected_versions": [
      [
        [
          2,
          5,
          1
        ],
        [
          2,
          5,
          5
        ]
      ],
      [
        [
          2,
          6,
          1
        ],
        [
          2,
          6,
          6
        ]
      ],
      [
        [
          3,
          1,
          1
        ],
        [
          3,
          1,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          1
        ],
        "commits": [
          "19e9fefc660d623ce7c31fb008cde1157ae12aba",
          "5ea3d0f95b51009fa1c3409e7dd1c12006427ccc"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        5
      ],
      [
        2,
        6
      ],
      [
        3,
        1
      ]
    ]
  },
  {
    "id": "PSF-2011-1",
    "cve": "CVE-2011-1015",
    "published": "2011-05-09T22:00:00+00:00",
    "modified": "2011-08-23T09:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue2254",
      "issue_number": "2254"
    },
    "details": "The is_cgi method in CGIHTTPServer.py in the CGIHTTPServer module in Python 2.5, 2.6, and 3.0 allows remote attackers to read script source code via an HTTP GET request that lacks a / (slash) character at the beginning of the URI.",
    "affected_versions": [
      [
        [
          2,
          5,
          1
        ],
        [
          2,
          5,
          5
        ]
      ],
      [
        [
          2,
          6,
          1
        ],
        [
          2,
          6,
          6
        ]
      ],
      [
        [
          3,
          1,
          1
        ],
        [
          3,
          1,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          1
        ],
        "commits": [
          "923ba361d8f757f0656cfd216525aca4848e02aa"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        5
      ],
      [
        2,
        6
      ],
      [
        3,
        1
      ]
    ]
  },
  {
    "id": "PSF-2011-2",
    "cve": "CVE-2011-1521",
    "published": "2011-05-24T23:00:00+00:00",
    "modified": "2014-02-10T16:57:01+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue11662",
      "issue_number": "11662"
    },
    "details": "The urllib and urllib2 modules in Python 2.x before 2.7.2 and 3.x before 3.2.1 process Location headers that specify redirection to file: URLs, which makes it easier for remote attackers to obtain sensitive information or cause a denial of service (resource consumption) via a crafted URL, as demonstrated by the file:///etc/passwd and file:///dev/zero URLs.",
    "affected_versions": [
      [
        [
          2,
          5,
          1
        ],
        [
          2,
          5,
          5
        ]
      ],
      [
        [
          2,
          6,
          1
        ],
        [
          2,
          6,
          6
        ]
      ],
      [
        [
          2,
          7,
          1
        ]
      ],
      [
        [
          3,
          1,
          1
        ],
        [
          3,
          1,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          5,
          6
        ],
        "commits": [
          "60a4a90c8dd2972eb4bb977e70835be9593cbbac"
        ]
      },
      {
        "version": [
          2,
          7,
          2
        ],
        "commits": [
          "a119df91f33724f64e6bc1ecb484eeaa30ace014"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        6
      ],
      [
        3,
        1
      ]
    ]
  },
  {
    "id": "PSF-2011-3",
    "cve": "CVE-2011-3389",
    "published": "2011-09-06T19:00:00+00:00",
    "modified": "2020-01-21T21:06:36+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue13885",
      "issue_number": "13885"
    },
    "details": "The SSL protocol, as used in certain configurations in Microsoft Windows and Microsoft Internet Explorer, Mozilla Firefox, Google Chrome, Opera, and other products, encrypts data by using CBC mode with chained initialization vectors, which allows man-in-the-middle attackers to obtain plaintext HTTP headers via a blockwise chosen-boundary attack (BCBA) on an HTTPS session, in conjunction with JavaScript code that uses (1) the HTML5 WebSocket API, (2) the Java URLConnection API, or (3) the Silverlight WebClient API, aka a \"BEAST\" attack.",
    "affected_versions": [
      [
        [
          2,
          6,
          1
        ],
        [
          2,
          6,
          7
        ]
      ],
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          2
        ]
      ],
      [
        [
          3,
          1,
          1
        ],
        [
          3,
          1,
          4
        ]
      ],
      [
        [
          3,
          2,
          1
        ],
        [
          3,
          2,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          6,
          8
        ],
        "commits": [
          "d358e0554bc520768041652676ec8e6076f221a9"
        ]
      },
      {
        "version": [
          2,
          7,
          3
        ],
        "commits": [
          "f2bf8a6ac51530e14d798a03c8e950dd934d85cd"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        1
      ],
      [
        3,
        2
      ]
    ]
  },
  {
    "id": "PSF-2012-1",
    "cve": "CVE-2011-4940",
    "published": "2012-06-27T10:00:00+00:00",
    "modified": "2012-10-13T09:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue11442",
      "issue_number": "11442"
    },
    "details": "The list_directory function in Lib/SimpleHTTPServer.py in SimpleHTTPServer in Python before 2.5.6c1, 2.6.x before 2.6.7 rc2, and 2.7.x before 2.7.2 does not place a charset parameter in the Content-Type HTTP header, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer 7 via UTF-7 encoding.",
    "affected_versions": [
      [
        [
          2,
          6,
          1
        ],
        [
          2,
          6,
          6
        ]
      ],
      [
        [
          2,
          7,
          1
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          5,
          6
        ],
        "commits": [
          "3853586e0caa0d5c4342ac8bd7e78cb5766fa8cc"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        6
      ],
      [
        2,
        7
      ]
    ]
  },
  {
    "id": "PSF-2012-2",
    "cve": "CVE-2011-4944",
    "published": "2012-08-27T23:00:00+00:00",
    "modified": "2020-01-21T21:06:20+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue13512",
      "issue_number": "13512"
    },
    "details": "Python 2.6 through 3.2 creates ~/.pypirc with world-readable permissions before changing them after data has been written, which introduces a race condition that allows local users to obtain a username and password by reading this file.",
    "affected_versions": [
      [
        [
          2,
          6,
          1
        ],
        [
          2,
          6,
          8
        ]
      ],
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          3
        ]
      ],
      [
        [
          3,
          2,
          1
        ],
        [
          3,
          2,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          4
        ],
        "commits": [
          "d61926e6bef6c4d8105a2848362377dce91d7fc8",
          "e5567ccc863cadb68f5e57a2760e021e0d3807cf"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        6
      ],
      [
        3,
        2
      ]
    ]
  },
  {
    "id": "PSF-2012-3",
    "cve": "CVE-2012-0845",
    "published": "2012-10-05T21:00:00+00:00",
    "modified": "2020-01-21T21:06:29+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue14001",
      "issue_number": "14001"
    },
    "details": "SimpleXMLRPCServer.py in SimpleXMLRPCServer in Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via an XML-RPC POST request that contains a smaller amount of data than specified by the Content-Length header.",
    "affected_versions": [
      [
        [
          2,
          6,
          1
        ],
        [
          2,
          6,
          7
        ]
      ],
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          2
        ]
      ],
      [
        [
          3,
          2,
          1
        ],
        [
          3,
          2,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          6,
          8
        ],
        "commits": [
          "66f3cc6f8de83c447d937160e4a1630c4482b5f5"
        ]
      },
      {
        "version": [
          2,
          7,
          3
        ],
        "commits": [
          "ec1712a1662282c909b4cd4cc0c7486646bc9246"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        2
      ]
    ]
  },
  {
    "id": "PSF-2012-4",
    "cve": "CVE-2012-0876",
    "published": "2012-07-03T19:00:00+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue30694",
      "issue_number": "30694"
    },
    "details": "The XML parser (xmlparse.c) in expat before 2.1.0 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via an XML file with many identifiers with the same value.",
    "affected_versions": [
      [
        [
          2,
          6,
          1
        ],
        [
          2,
          6,
          8
        ]
      ],
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          3
        ]
      ],
      [
        [
          3,
          2,
          1
        ],
        [
          3,
          2,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          14
        ],
        "commits": [
          "2ada64d2a073f85f135461833952dbe8d656810d"
        ]
      },
      {
        "version": [
          3,
          3,
          7
        ],
        "commits": [
          "ab90986600ba7dea2aa41e5c1773791070725453"
        ]
      },
      {
        "version": [
          3,
          4,
          7
        ],
        "commits": [
          "71572bbe82aa0836c036d44d41c8269ba6a321be"
        ]
      },
      {
        "version": [
          3,
          5,
          4
        ],
        "commits": [
          "91d171be45942d37a973b0675521b5159a96be31"
        ]
      },
      {
        "version": [
          3,
          6,
          2
        ],
        "commits": [
          "ea1ab803ddc14ab02ffed50ecc5089897f259623"
        ]
      },
      {
        "version": [
          3,
          7,
          0
        ],
        "commits": [
          "5ff7132313eb651107b179d20218dfe5d4e47f13"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        6
      ],
      [
        3,
        2
      ]
    ]
  },
  {
    "id": "PSF-2012-5",
    "cve": "CVE-2012-1150",
    "published": "2012-10-05T21:00:00+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue13703",
      "issue_number": "13703"
    },
    "details": "Python before 2.6.8, 2.7.x before 2.7.3, 3.x before 3.1.5, and 3.2.x before 3.2.3 computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.",
    "affected_versions": [
      [
        [
          2,
          6,
          1
        ],
        [
          2,
          6,
          7
        ]
      ],
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          2
        ]
      ],
      [
        [
          3,
          2,
          1
        ],
        [
          3,
          2,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          6,
          8
        ],
        "commits": [
          "1e13eb084f72d5993cbb726e45b36bdb69c83a24"
        ]
      },
      {
        "version": [
          2,
          7,
          3
        ],
        "commits": [
          "2daf6ae2495c862adf8bc717bfe9964081ea0b10"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        2
      ]
    ]
  },
  {
    "id": "PSF-2012-6",
    "cve": "CVE-2012-2135",
    "published": "2012-08-14T22:00:00+00:00",
    "modified": "2013-01-29T10:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue14579",
      "issue_number": "14579"
    },
    "details": "The utf-16 decoder in Python 3.1 through 3.3 does not update the aligned_end variable after calling the unicode_decode_call_errorhandler function, which allows remote attackers to obtain sensitive information (process memory) or cause a denial of service (memory corruption and crash) via unspecified vectors.",
    "affected_versions": [
      [
        [
          2,
          6,
          1
        ],
        [
          2,
          6,
          8
        ]
      ],
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          3
        ]
      ],
      [
        [
          3,
          2,
          1
        ],
        [
          3,
          2,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          4
        ],
        "commits": [
          "715a63b78349952ccc0fb3dd3139e2d822006d35",
          "b4bbee25b1e3f4bccac222f806b3138fb72439d6"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        6
      ],
      [
        3,
        2
      ]
    ]
  },
  {
    "id": "PSF-2013-1",
    "cve": "CVE-2013-2099",
    "published": "2013-10-09T14:44:00+00:00",
    "modified": "2017-01-23T18:57:01+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue17980",
      "issue_number": "17980"
    },
    "details": "Algorithmic complexity vulnerability in the ssl.match_hostname function in Python 3.2.x, 3.3.x, and earlier, and unspecified versions of python-backports-ssl_match_hostname as used for older Python versions, allows remote attackers to cause a denial of service (CPU consumption) via multiple wildcard characters in the common name in a certificate.",
    "affected_versions": [
      [
        [
          2,
          6,
          1
        ],
        [
          2,
          6,
          8
        ]
      ],
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          5
        ]
      ],
      [
        [
          3,
          2,
          1
        ],
        [
          3,
          2,
          5
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          2,
          6
        ],
        "commits": [
          "86d53caddad11808ca332ab93ec35508b602a0dd"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        6
      ],
      [
        2,
        7
      ],
      [
        3,
        3
      ]
    ]
  },
  {
    "id": "PSF-2013-2",
    "cve": "CVE-2013-4238",
    "published": "2013-08-18T01:00:00+00:00",
    "modified": "2020-01-21T21:06:34+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue18709",
      "issue_number": "18709"
    },
    "details": "The ssl.match_hostname function in the SSL module in Python 2.6 through 3.4 does not properly handle a '\\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority, a related issue to CVE-2009-2408.",
    "affected_versions": [
      [
        [
          2,
          6,
          1
        ],
        [
          2,
          6,
          8
        ]
      ],
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          5
        ]
      ],
      [
        [
          3,
          2,
          1
        ],
        [
          3,
          2,
          5
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          6,
          9
        ],
        "commits": [
          "82f88283171933127f20f866a7f98694b29cca56"
        ]
      },
      {
        "version": [
          3,
          2,
          6
        ],
        "commits": [
          "ec3c103520a5061e657581b388e2b8ba6f74602a"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        7
      ],
      [
        3,
        3
      ]
    ]
  },
  {
    "id": "PSF-2013-3",
    "cve": null,
    "published": "2013-10-29T00:00:00+00:00",
    "modified": "0001-01-01T00:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue19435",
      "issue_number": "19435"
    },
    "details": "An error in separating the path and filename of the CGI script to run in\n``http.server.CGIHTTPRequestHandler`` allows running arbitrary executables\nin the directory under which the server was started.\n",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          5
        ]
      ],
      [
        [
          3,
          2,
          1
        ],
        [
          3,
          2,
          5
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          6
        ],
        "commits": [
          "1ef959ac3ddc4d96dfa1a613db5cb206cdaeb662"
        ]
      },
      {
        "version": [
          3,
          2,
          6
        ],
        "commits": [
          "04e9de40f380b2695f955d68f2721d57cecbf858"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        3
      ]
    ]
  },
  {
    "id": "PSF-2014-1",
    "cve": "CVE-2013-0340",
    "published": "2014-01-21T18:00:00+00:00",
    "modified": "2021-10-27T18:07:35+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue44394",
      "issue_number": "44394"
    },
    "details": "expat 2.1.0 and earlier does not properly handle entities expansion unless an application developer uses the XML_SetEntityDeclHandler function, which allows remote attackers to cause a denial of service (resource consumption), send HTTP requests to intranet servers, or read arbitrary files via a crafted XML document, aka an XML External Entity (XXE) issue.  NOTE: it could be argued that because expat already provides the ability to disable external entity expansion, the responsibility for resolving this issue lies with application developers; according to this argument, this entry should be REJECTed, and each affected application would need its own CVE.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          6
        ]
      ],
      [
        [
          3,
          2,
          1
        ],
        [
          3,
          2,
          5
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          6,
          15
        ],
        "commits": [
          "910886a6448e4bf1edf49eeace4aa240b6403772"
        ]
      },
      {
        "version": [
          3,
          7,
          12
        ],
        "commits": [
          "79101b890ee021a901a8b6837a3a320d57adb725"
        ]
      },
      {
        "version": [
          3,
          8,
          12
        ],
        "commits": [
          "c9c2a0bc9820f93f1020f3498f6893a3544c9b76"
        ]
      },
      {
        "version": [
          3,
          9,
          7
        ],
        "commits": [
          "007221a43e566db08c0c5c00756d80dfd9dccafe"
        ]
      },
      {
        "version": [
          3,
          10,
          0
        ],
        "commits": [
          "270678564c16452614a8acd93763bdf64fb4d286"
        ]
      },
      {
        "version": [
          3,
          11,
          0
        ],
        "commits": [
          "3fc5d84046ddbd66abac5b598956ea34605a4e5d"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        7
      ],
      [
        3,
        2
      ],
      [
        3,
        3
      ]
    ]
  },
  {
    "id": "PSF-2014-2",
    "cve": "CVE-2013-7040",
    "published": "2014-05-19T14:00:00+00:00",
    "modified": "2016-11-25T19:57:01+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue14621",
      "issue_number": "14621"
    },
    "details": "Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          6
        ]
      ],
      [
        [
          3,
          2,
          1
        ],
        [
          3,
          2,
          5
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          5
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          4,
          0
        ],
        "commits": [
          "985ecdcfc29adfc36ce2339acf03f819ad414869"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        7
      ],
      [
        3,
        2
      ],
      [
        3,
        3
      ]
    ]
  },
  {
    "id": "PSF-2014-3",
    "cve": "CVE-2013-7338",
    "published": "2014-04-22T14:00:00+00:00",
    "modified": "2017-06-30T16:57:01+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue20078",
      "issue_number": "20078"
    },
    "details": "Python before 3.3.4 RC1 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via a file size value larger than the size of the zip file to the (1) ZipExtFile.read, (2) ZipExtFile.read(n), (3) ZipExtFile.readlines, (4) ZipFile.extract, or (5) ZipFile.extractall function.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          6
        ]
      ],
      [
        [
          3,
          2,
          1
        ],
        [
          3,
          2,
          5
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          3,
          4
        ],
        "commits": [
          "5ce3f10aeea711bb912e948fa5d9f63736df1327"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        7
      ],
      [
        3,
        2
      ]
    ]
  },
  {
    "id": "PSF-2014-4",
    "cve": "CVE-2014-1912",
    "published": "2014-02-28T18:00:00+00:00",
    "modified": "2018-01-04T19:57:01+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue20246",
      "issue_number": "20246"
    },
    "details": "Buffer overflow in the socket.recvfrom_into function in Modules/socketmodule.c in Python 2.5 before 2.7.7, 3.x before 3.3.4, and 3.4.x before 3.4rc1 allows remote attackers to execute arbitrary code via a crafted string.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          6
        ]
      ],
      [
        [
          3,
          2,
          1
        ],
        [
          3,
          2,
          5
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          7
        ],
        "commits": [
          "28cf368c1baba3db1f01010e921f63017af74c8f"
        ]
      },
      {
        "version": [
          3,
          2,
          6
        ],
        "commits": [
          "fbf648ebba32bbc5aa571a4b09e2062a65fd2492"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        3
      ]
    ]
  },
  {
    "id": "PSF-2014-5",
    "cve": "CVE-2014-2667",
    "published": "2014-11-16T01:00:00+00:00",
    "modified": "2020-01-21T21:06:40+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue21082",
      "issue_number": "21082"
    },
    "details": "Race condition in the _get_masked_mode function in Lib/os.py in Python 3.2 through 3.5, when exist_ok is set to true and multiple threads are used, might allow local users to bypass intended file permissions by leveraging a separate application vulnerability before the umask has been set to the expected value.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          8
        ]
      ],
      [
        [
          3,
          2,
          1
        ],
        [
          3,
          2,
          5
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          5
        ]
      ],
      [
        [
          3,
          4,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          2,
          6
        ],
        "commits": [
          "ee5f1c13d1ea21c628068fdf142823177f5526c2"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        7
      ],
      [
        3,
        3
      ],
      [
        3,
        4
      ]
    ]
  },
  {
    "id": "PSF-2014-6",
    "cve": "CVE-2014-7185",
    "published": "2014-10-08T17:00:00+00:00",
    "modified": "2018-01-04T19:57:01+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue21831",
      "issue_number": "21831"
    },
    "details": "Integer overflow in bufferobject.c in Python before 2.7.8 allows context-dependent attackers to obtain sensitive information from process memory via a large size and offset in a \"buffer\" function.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          7
        ]
      ],
      [
        [
          3,
          2,
          1
        ],
        [
          3,
          2,
          5
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          5
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          8
        ],
        "commits": [
          "550b945fd66f1c6837a53fbf29dc8e524297b8c3"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        2
      ],
      [
        3,
        3
      ],
      [
        3,
        4
      ]
    ]
  },
  {
    "id": "PSF-2014-7",
    "cve": "CVE-2014-9365",
    "published": "2014-12-12T11:00:00+00:00",
    "modified": "2018-01-04T19:57:01+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue22417",
      "issue_number": "22417"
    },
    "details": "The HTTP clients in the (1) httplib, (2) urllib, (3) urllib2, and (4) xmlrpclib libraries in CPython (aka Python) 2.x before 2.7.9 and 3.x before 3.4.3, when accessing an HTTPS URL, do not (a) check the certificate against a trust store or verify that the server hostname matches a domain name in the subject's (b) Common Name or (c) subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          8
        ]
      ],
      [
        [
          3,
          2,
          1
        ],
        [
          3,
          2,
          6
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          6
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          9
        ],
        "commits": [
          "e3e7d40514e5dd0c3847682a719577efcfae1d8f"
        ]
      },
      {
        "version": [
          3,
          4,
          3
        ],
        "commits": [
          "4ffb0752710f0c0720d4f2af0c4b7ce1ebb9d2bd"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        2
      ],
      [
        3,
        3
      ]
    ]
  },
  {
    "id": "PSF-2015-1",
    "cve": "CVE-2015-1283",
    "published": "2015-07-23T00:00:00+00:00",
    "modified": "2021-07-31T07:06:31+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue26556",
      "issue_number": "26556"
    },
    "details": "Multiple integer overflows in the XML_GetBuffer function in Expat through 2.1.0, as used in Google Chrome before 44.0.2403.89 and other products, allow remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via crafted XML data, a related issue to CVE-2015-2716.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          10
        ]
      ],
      [
        [
          3,
          2,
          1
        ],
        [
          3,
          2,
          6
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          6
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          12
        ],
        "commits": [
          "d244a8f7cb0ec6979ec9fc7acd39e95f5339ad0e"
        ]
      },
      {
        "version": [
          3,
          3,
          7
        ],
        "commits": [
          "ab90986600ba7dea2aa41e5c1773791070725453"
        ]
      },
      {
        "version": [
          3,
          4,
          5
        ],
        "commits": [
          "196d7db3956f4c0b03e87b570771b3460a61bab5"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        2
      ]
    ]
  },
  {
    "id": "PSF-2016-1",
    "cve": "CVE-2013-7440",
    "published": "2016-06-07T18:00:00+00:00",
    "modified": "2016-11-25T19:57:01+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue17997",
      "issue_number": "17997"
    },
    "details": "The ssl.match_hostname function in CPython (aka Python) before 2.7.9 and 3.x before 3.3.3 does not properly handle wildcards in hostnames, which might allow man-in-the-middle attackers to spoof servers via a crafted certificate.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          11
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          3,
          3
        ],
        "commits": [
          "72c98d3a761457a4f2b8054458b19f051dfb5886"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        7
      ]
    ]
  },
  {
    "id": "PSF-2016-2",
    "cve": "CVE-2016-0718",
    "published": "2016-05-26T16:00:00+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue29591",
      "issue_number": "29591"
    },
    "details": "Expat allows context-dependent attackers to cause a denial of service (crash) or possibly execute arbitrary code via a malformed input document, which triggers a buffer overflow.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          11
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          6
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          4
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          1
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          14
        ],
        "commits": [
          "0e4571a68a7f48e8469ef05b04ba3463d3fd82c0",
          "2ada64d2a073f85f135461833952dbe8d656810d"
        ]
      },
      {
        "version": [
          3,
          3,
          7
        ],
        "commits": [
          "ab90986600ba7dea2aa41e5c1773791070725453"
        ]
      },
      {
        "version": [
          3,
          4,
          7
        ],
        "commits": [
          "71572bbe82aa0836c036d44d41c8269ba6a321be"
        ]
      },
      {
        "version": [
          3,
          5,
          4
        ],
        "commits": [
          "8c797ed8a0fea5e3162b9415f13e270d4d5d9549",
          "91d171be45942d37a973b0675521b5159a96be31"
        ]
      },
      {
        "version": [
          3,
          6,
          2
        ],
        "commits": [
          "86b95370c45dedb8a56c9894372a43681de47a73",
          "ea1ab803ddc14ab02ffed50ecc5089897f259623"
        ]
      },
      {
        "version": [
          3,
          7,
          0
        ],
        "commits": [
          "23ec4b57e1359f9c539b8defc317542173ae087e",
          "5ff7132313eb651107b179d20218dfe5d4e47f13"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2016-3",
    "cve": "CVE-2016-0772",
    "published": "2016-09-02T14:00:00+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": null,
    "details": "The smtplib library in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 does not return an error when StartTLS fails, which might allow man-in-the-middle attackers to bypass the TLS protections by leveraging a network position between the client and the registry to block the StartTLS command, aka a \"StartTLS stripping attack.\"",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          11
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          6
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          4
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          1
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          12
        ],
        "commits": [
          "2e1b7fc998e1744eeb3bb31b131eba0145b88a2f"
        ]
      },
      {
        "version": [
          3,
          3,
          7
        ],
        "commits": [
          "3625f7fd11679ecb390ffa58ef36d487acc8159b"
        ]
      },
      {
        "version": [
          3,
          4,
          5
        ],
        "commits": [
          "46b32f307c48bcb999b22eebf65ffe8ed5cca544"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        5
      ]
    ]
  },
  {
    "id": "PSF-2016-4",
    "cve": "CVE-2016-2183",
    "published": "2016-09-01T00:00:00+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue27850",
      "issue_number": "27850"
    },
    "details": "The DES and Triple DES ciphers, as used in the TLS, SSH, and IPSec protocols and other protocols and products, have a birthday bound of approximately four billion blocks, which makes it easier for remote attackers to obtain cleartext data via a birthday attack against a long-duration encrypted session, as demonstrated by an HTTPS session using Triple DES in CBC mode, aka a \"Sweet32\" attack.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          12
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          6
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          5
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          13
        ],
        "commits": [
          "d988f429fe43808345812ef63dfa8da170c61871"
        ]
      },
      {
        "version": [
          3,
          4,
          7
        ],
        "commits": [
          "fa53dbdec818b0f2a0e22ca12a49d83ec948fc91"
        ]
      },
      {
        "version": [
          3,
          5,
          3
        ],
        "commits": [
          "03d13c0cbfe912eb0f9b9a02987b9e569f25fe19"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        3
      ]
    ]
  },
  {
    "id": "PSF-2016-5",
    "cve": "CVE-2016-3189",
    "published": "2016-06-30T17:00:00+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue44549",
      "issue_number": "44549"
    },
    "details": "Use-after-free vulnerability in bzip2recover in bzip2 1.0.6 allows remote attackers to cause a denial of service (crash) via a crafted bzip2 file, related to block ends set to before the start of the block.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          12
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          6
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          5
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          7,
          13
        ],
        "commits": [
          "4a3c610cd635f14747cf02c77908e80620aae6ea"
        ]
      },
      {
        "version": [
          3,
          8,
          13
        ],
        "commits": [
          "6649519e67841b1aa12672f1d9b5cb24494f6196"
        ]
      },
      {
        "version": [
          3,
          9,
          11
        ],
        "commits": [
          "e1639f361ee0dfbf08bb8538839d3d557c1a995c"
        ]
      },
      {
        "version": [
          3,
          10,
          3
        ],
        "commits": [
          "58d576a43cb1800dd68f06a429d7d41f746a8c01"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        7
      ],
      [
        3,
        3
      ],
      [
        3,
        4
      ],
      [
        3,
        5
      ]
    ]
  },
  {
    "id": "PSF-2016-6",
    "cve": "CVE-2016-4472",
    "published": "2016-06-30T17:00:00+00:00",
    "modified": "2021-07-31T07:06:45+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue29591",
      "issue_number": "29591"
    },
    "details": "The overflow protection in Expat is removed by compilers with certain optimization settings, which allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via crafted XML data.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-1283 and CVE-2015-2716.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          12
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          6
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          5
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          14
        ],
        "commits": [
          "0e4571a68a7f48e8469ef05b04ba3463d3fd82c0"
        ]
      },
      {
        "version": [
          3,
          3,
          7
        ],
        "commits": [
          "ab90986600ba7dea2aa41e5c1773791070725453"
        ]
      },
      {
        "version": [
          3,
          4,
          7
        ],
        "commits": [
          "71572bbe82aa0836c036d44d41c8269ba6a321be"
        ]
      },
      {
        "version": [
          3,
          5,
          4
        ],
        "commits": [
          "8c797ed8a0fea5e3162b9415f13e270d4d5d9549"
        ]
      },
      {
        "version": [
          3,
          6,
          2
        ],
        "commits": [
          "86b95370c45dedb8a56c9894372a43681de47a73"
        ]
      },
      {
        "version": [
          3,
          7,
          0
        ],
        "commits": [
          "23ec4b57e1359f9c539b8defc317542173ae087e"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2016-7",
    "cve": "CVE-2016-5636",
    "published": "2016-09-02T14:00:00+00:00",
    "modified": "2020-01-21T21:06:18+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue26171",
      "issue_number": "26171"
    },
    "details": "Integer overflow in the get_data function in zipimport.c in CPython (aka Python) before 2.7.12, 3.x before 3.4.5, and 3.5.x before 3.5.2 allows remote attackers to have unspecified impact via a negative data size value, which triggers a heap-based buffer overflow.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          11
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          6
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          5
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          12
        ],
        "commits": [
          "64ea192b73e39e877d8b39ce6584fa580eb0e9b4"
        ]
      },
      {
        "version": [
          3,
          3,
          7
        ],
        "commits": [
          "d751040b1a4e35fd3b01fc919cd8f9374ed714fd"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        4
      ],
      [
        3,
        5
      ]
    ]
  },
  {
    "id": "PSF-2016-8",
    "cve": "CVE-2016-5699",
    "published": "2016-09-02T14:00:00+00:00",
    "modified": "2020-01-21T21:06:39+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue22928",
      "issue_number": "22928"
    },
    "details": "CRLF injection vulnerability in the HTTPConnection.putheader function in urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in a URL.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          9
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          6
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          10
        ],
        "commits": [
          "59bdf6392de446de8a19bfa37cee52981612830e"
        ]
      },
      {
        "version": [
          3,
          3,
          7
        ],
        "commits": [
          "8e88f6b5e2a35ee458c161aa3f2b7f1f17fb45d1"
        ]
      },
      {
        "version": [
          3,
          4,
          4
        ],
        "commits": [
          "a112a8ae47813f75aa8ad27ee8c42a7c2e937d13"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2016-9",
    "cve": null,
    "published": "2016-03-28T00:00:00+00:00",
    "modified": "0001-01-01T00:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue26657",
      "issue_number": "26657"
    },
    "details": "Fix directory traversal vulnerability with ``http.server`` and\n``SimpleHTTPServer`` on Windows.\n\nRegression of Python 3.3.5.\n\nPython issue reported at 2016-03-14.\n",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          11
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          6
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          4
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          1
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          12
        ],
        "commits": [
          "0cf2cf2b7d726d12a6046441e4067d32c7dd4feb"
        ]
      },
      {
        "version": [
          3,
          3,
          7
        ],
        "commits": [
          "7b92f9fa47df754b50c64aac84cf1c09693571af"
        ]
      },
      {
        "version": [
          3,
          4,
          7
        ],
        "commits": [
          "6f6bc1da8aaae52664e7747e328d26eb59c0e74f"
        ]
      },
      {
        "version": [
          3,
          5,
          2
        ],
        "commits": [
          "d274b3f1f1e2d8811733fb952c9f18d7da3a376a"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2016-10",
    "cve": null,
    "published": "2016-10-30T00:00:00+00:00",
    "modified": "0001-01-01T00:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue28563",
      "issue_number": "28563"
    },
    "details": "Arbitrary code execution in ``gettext.c2py()``.\n",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          12
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          6
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          5
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          13
        ],
        "commits": [
          "a8760275bd59fb8d8be1f1bf05313fed31c08321"
        ]
      },
      {
        "version": [
          3,
          3,
          7
        ],
        "commits": [
          "07bcf05fcf3fd1d4001e8e3489162e6d67638285"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        4
      ],
      [
        3,
        5
      ]
    ]
  },
  {
    "id": "PSF-2017-1",
    "cve": "CVE-2014-4616",
    "published": "2017-08-24T20:00:00+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue21529",
      "issue_number": "21529"
    },
    "details": "Array index error in the scanstring function in the _json module in Python 2.7 through 3.5 and simplejson before 2.6.1 allows context-dependent attackers to read arbitrary process memory via a negative index value in the idx argument to the raw_decode function.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          6
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          5
        ]
      ],
      [
        [
          3,
          4,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          7
        ],
        "commits": [
          "6c939cb6f6dfbd273609577b0022542d31ae2802"
        ]
      },
      {
        "version": [
          3,
          2,
          6
        ],
        "commits": [
          "99b5afab74428e5ddfd877bdf3aa8a8c479696b1"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        3
      ],
      [
        3,
        4
      ]
    ]
  },
  {
    "id": "PSF-2017-2",
    "cve": "CVE-2016-9840",
    "published": "2017-05-23T03:56:00+00:00",
    "modified": "2021-01-06T16:16:02+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue29169",
      "issue_number": "29169"
    },
    "details": "inftrees.c in zlib 1.2.8 might allow context-dependent attackers to have unspecified impact by leveraging improper pointer arithmetic.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          13
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          6
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          6
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          3
        ]
      ],
      [
        [
          3,
          6,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          14
        ],
        "commits": [
          "80b24a9354c60f6b800d462c941c6d4cde3cf783"
        ]
      },
      {
        "version": [
          3,
          4,
          8
        ],
        "commits": [
          "d0e61bded5256e775e470e2c0da22367a1a81970"
        ]
      },
      {
        "version": [
          3,
          5,
          4
        ],
        "commits": [
          "34e7e2ecb1741850190e78f42875480693d3537b"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        3
      ],
      [
        3,
        6
      ]
    ]
  },
  {
    "id": "PSF-2017-3",
    "cve": "CVE-2016-9841",
    "published": "2017-05-23T03:56:00+00:00",
    "modified": "2021-01-06T16:16:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue29169",
      "issue_number": "29169"
    },
    "details": "inffast.c in zlib 1.2.8 might allow context-dependent attackers to have unspecified impact by leveraging improper pointer arithmetic.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          13
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          6
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          6
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          3
        ]
      ],
      [
        [
          3,
          6,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          14
        ],
        "commits": [
          "80b24a9354c60f6b800d462c941c6d4cde3cf783"
        ]
      },
      {
        "version": [
          3,
          4,
          8
        ],
        "commits": [
          "d0e61bded5256e775e470e2c0da22367a1a81970"
        ]
      },
      {
        "version": [
          3,
          5,
          4
        ],
        "commits": [
          "34e7e2ecb1741850190e78f42875480693d3537b"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        3
      ],
      [
        3,
        6
      ]
    ]
  },
  {
    "id": "PSF-2017-4",
    "cve": "CVE-2016-9842",
    "published": "2017-05-23T03:56:00+00:00",
    "modified": "2021-01-06T16:16:04+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue29169",
      "issue_number": "29169"
    },
    "details": "The inflateMark function in inflate.c in zlib 1.2.8 might allow context-dependent attackers to have unspecified impact via vectors involving left shifts of negative integers.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          13
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          6
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          6
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          3
        ]
      ],
      [
        [
          3,
          6,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          14
        ],
        "commits": [
          "80b24a9354c60f6b800d462c941c6d4cde3cf783"
        ]
      },
      {
        "version": [
          3,
          4,
          8
        ],
        "commits": [
          "d0e61bded5256e775e470e2c0da22367a1a81970"
        ]
      },
      {
        "version": [
          3,
          5,
          4
        ],
        "commits": [
          "34e7e2ecb1741850190e78f42875480693d3537b"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        3
      ],
      [
        3,
        6
      ]
    ]
  },
  {
    "id": "PSF-2017-5",
    "cve": "CVE-2016-9843",
    "published": "2017-05-23T03:56:00+00:00",
    "modified": "2021-01-06T16:15:49+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue29169",
      "issue_number": "29169"
    },
    "details": "The crc32_big function in crc32.c in zlib 1.2.8 might allow context-dependent attackers to have unspecified impact via vectors involving big-endian CRC calculation.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          13
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          6
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          6
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          3
        ]
      ],
      [
        [
          3,
          6,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          14
        ],
        "commits": [
          "80b24a9354c60f6b800d462c941c6d4cde3cf783"
        ]
      },
      {
        "version": [
          3,
          4,
          8
        ],
        "commits": [
          "d0e61bded5256e775e470e2c0da22367a1a81970"
        ]
      },
      {
        "version": [
          3,
          5,
          4
        ],
        "commits": [
          "34e7e2ecb1741850190e78f42875480693d3537b"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        3
      ],
      [
        3,
        6
      ]
    ]
  },
  {
    "id": "PSF-2017-6",
    "cve": "CVE-2017-1000158",
    "published": "2017-11-17T00:00:00+00:00",
    "modified": "2023-02-16T00:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue30657",
      "issue_number": "30657"
    },
    "details": "CPython (aka Python) up to 2.7.13 is vulnerable to an integer overflow in the PyString_DecodeEscape function in stringobject.c, resulting in heap-based buffer overflow (and possible arbitrary code execution)",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          13
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          7
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          4
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          14
        ],
        "commits": [
          "c3c9db89273fabc62ea1b48389d9a3000c1c03ae"
        ]
      },
      {
        "version": [
          3,
          4,
          8
        ],
        "commits": [
          "6c004b40f9d51872d848981ef1a18bb08c2dfc42"
        ]
      },
      {
        "version": [
          3,
          5,
          5
        ],
        "commits": [
          "fd8614c5c5466a14a945db5b059c10c0fb8f76d9"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        6
      ]
    ]
  },
  {
    "id": "PSF-2017-7",
    "cve": "CVE-2017-9233",
    "published": "2017-07-25T20:00:00+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue30694",
      "issue_number": "30694"
    },
    "details": "XML External Entity vulnerability in libexpat 2.2.0 and earlier (Expat XML Parser Library) allows attackers to put the parser in an infinite loop using a malformed external entity definition from an external DTD.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          13
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          6
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          6
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          3
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          1
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          14
        ],
        "commits": [
          "2ada64d2a073f85f135461833952dbe8d656810d"
        ]
      },
      {
        "version": [
          3,
          3,
          7
        ],
        "commits": [
          "ab90986600ba7dea2aa41e5c1773791070725453"
        ]
      },
      {
        "version": [
          3,
          4,
          7
        ],
        "commits": [
          "71572bbe82aa0836c036d44d41c8269ba6a321be"
        ]
      },
      {
        "version": [
          3,
          5,
          4
        ],
        "commits": [
          "91d171be45942d37a973b0675521b5159a96be31"
        ]
      },
      {
        "version": [
          3,
          6,
          2
        ],
        "commits": [
          "ea1ab803ddc14ab02ffed50ecc5089897f259623"
        ]
      },
      {
        "version": [
          3,
          7,
          0
        ],
        "commits": [
          "5ff7132313eb651107b179d20218dfe5d4e47f13"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2017-8",
    "cve": null,
    "published": "2017-06-22T00:00:00+00:00",
    "modified": "0001-01-01T00:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue30730",
      "issue_number": "30730"
    },
    "details": "On Windows, prevent passing invalid environment variables and command\narguments to subprocess.Popen.\n\nIt is possible to inject an environment variable in subprocess on Windows\nif a user data is passed to a subprocess via environment variable.\n\nCheck for invalid environment (variable names containing '=') and command\narguments (containing '\\0').\n",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          13
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          6
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          6
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          3
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          1
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          14
        ],
        "commits": [
          "9dda2caca8edc7ff1285f6b0d1c5279b51854b7d"
        ]
      },
      {
        "version": [
          3,
          3,
          7
        ],
        "commits": [
          "e46f1c19642ea1882f427d8246987ba49351a97d"
        ]
      },
      {
        "version": [
          3,
          4,
          7
        ],
        "commits": [
          "fe82c46327effc124ff166e1fa1e611579e1176b"
        ]
      },
      {
        "version": [
          3,
          5,
          4
        ],
        "commits": [
          "a7c0264735f46afab13771be4218d8eab0d7dc91"
        ]
      },
      {
        "version": [
          3,
          6,
          2
        ],
        "commits": [
          "a9b16cff35811f88cdfeb4f50758140dfff36ebc"
        ]
      },
      {
        "version": [
          3,
          7,
          0
        ],
        "commits": [
          "d174d24a5d37d1516b885dc7c82f71ecd5930700"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2017-9",
    "cve": null,
    "published": "2017-05-29T00:00:00+00:00",
    "modified": "0001-01-01T00:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue30500",
      "issue_number": "30500"
    },
    "details": "The urllib module doesn't parse correctly password containing the ``#``\ncharacter.\n",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          13
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          6
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          6
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          3
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          1
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          14
        ],
        "commits": [
          "d4324baca4c03eb8d55446cd1b74b32ec5633af5"
        ]
      },
      {
        "version": [
          3,
          3,
          7
        ],
        "commits": [
          "052f9d6860c48c5abcff8e16212e77cf4249d66c"
        ]
      },
      {
        "version": [
          3,
          4,
          7
        ],
        "commits": [
          "cc54c1c0d2d05fe7404ba64c53df4b1352ed2262"
        ]
      },
      {
        "version": [
          3,
          5,
          4
        ],
        "commits": [
          "4899d847ed3f56b2a712799f896aa1f28540a5c0"
        ]
      },
      {
        "version": [
          3,
          6,
          2
        ],
        "commits": [
          "b0fba8874a4bd6bf4773e6efdbd8fa762e9f05bd"
        ]
      },
      {
        "version": [
          3,
          7,
          0
        ],
        "commits": [
          "90e01e50ef8a9e6c91f30d965563c378a4ad26de"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2017-10",
    "cve": null,
    "published": "2017-04-20T00:00:00+00:00",
    "modified": "0001-01-01T00:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue30119",
      "issue_number": "30119"
    },
    "details": "FTP protocol stream injection via malicious URLs.\n",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          13
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          6
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          6
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          3
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          1
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          14
        ],
        "commits": [
          "e5eae474c431af2880a68f6329840b9288fc4bc1"
        ]
      },
      {
        "version": [
          3,
          3,
          7
        ],
        "commits": [
          "a4e774f86224cd8c997deaa4e71312cf1a7b023c"
        ]
      },
      {
        "version": [
          3,
          4,
          7
        ],
        "commits": [
          "2a5a26c87e82c7d9a348792891feccd1b5e9a769"
        ]
      },
      {
        "version": [
          3,
          5,
          4
        ],
        "commits": [
          "19b2890014d3098147d16475c492a47a43893768"
        ]
      },
      {
        "version": [
          3,
          6,
          3
        ],
        "commits": [
          "8c2d4cf092c5f0335e7982392a33927579c4d512"
        ]
      },
      {
        "version": [
          3,
          7,
          0
        ],
        "commits": [
          "2b1e6e9696cb433c0e0da11145157d54275d119f"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2017-11",
    "cve": null,
    "published": "2017-07-17T00:00:00+00:00",
    "modified": "0001-01-01T00:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue30947",
      "issue_number": "30947"
    },
    "details": "Expat 2.2.2 was released with multiple security fixes:\n\n* #43: Protect against compilation without any source of high quality\n  entropy enabled, e.g. with CMake build system\n* #60: Windows with _UNICODE: Unintended use of LoadLibraryW with a non-wide\n  string resulted in failure to load advapi32.dll and degradation in quality\n  of used entropy when compiled with _UNICODE for Windows; you can launch\n  existing binaries with EXPAT_ENTROPY_DEBUG=1 in the environment to inspect\n  the quality of entropy used during runtime\n* [MOX-006]: Fix non-NULL parser parameter validation in XML_Parse; resulted\n  in NULL dereference, previously\n\nExpat 2.2.3 contains an additional security fix: #82: CVE-2017-11742 --\nWindows: Fix DLL hijacking vulnerability using Steve Holme's LoadLibrary\nwrapper for/of cURL\n",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          13
        ]
      ],
      [
        [
          3,
          3,
          0
        ],
        [
          3,
          3,
          6
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          6
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          3
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          14
        ],
        "commits": [
          "ec4ab09b7c0b5070bdb27351f979cbecc4636245"
        ]
      },
      {
        "version": [
          3,
          3,
          7
        ],
        "commits": [
          "297516ea509c72d8ebed3a9b3ce200f023aca0b7"
        ]
      },
      {
        "version": [
          3,
          4,
          8
        ],
        "commits": [
          "86a713cb0c110b6798ca7f9e630fc511ee0a4028"
        ]
      },
      {
        "version": [
          3,
          5,
          5
        ],
        "commits": [
          "f2492bb6aae061aea47e21fc7e56b7ab9bfdf543"
        ]
      },
      {
        "version": [
          3,
          6,
          3
        ],
        "commits": [
          "83e37e16f3065086d721d4e62a3788e01db3431c"
        ]
      },
      {
        "version": [
          3,
          7,
          0
        ],
        "commits": [
          "93d0cb58b4da2a88c56f472c6c19491cc7a390df"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2018-1",
    "cve": "CVE-2016-9063",
    "published": "2018-06-11T21:00:00+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue30694",
      "issue_number": "30694"
    },
    "details": "An integer overflow during the parsing of XML using the Expat library. This vulnerability affects Firefox < 50.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          13
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          6
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          3
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          1
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          14
        ],
        "commits": [
          "2ada64d2a073f85f135461833952dbe8d656810d"
        ]
      },
      {
        "version": [
          3,
          3,
          7
        ],
        "commits": [
          "ab90986600ba7dea2aa41e5c1773791070725453"
        ]
      },
      {
        "version": [
          3,
          4,
          7
        ],
        "commits": [
          "71572bbe82aa0836c036d44d41c8269ba6a321be"
        ]
      },
      {
        "version": [
          3,
          5,
          4
        ],
        "commits": [
          "91d171be45942d37a973b0675521b5159a96be31"
        ]
      },
      {
        "version": [
          3,
          6,
          2
        ],
        "commits": [
          "ea1ab803ddc14ab02ffed50ecc5089897f259623"
        ]
      },
      {
        "version": [
          3,
          7,
          0
        ],
        "commits": [
          "5ff7132313eb651107b179d20218dfe5d4e47f13"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2018-2",
    "cve": "CVE-2018-1000030",
    "published": "2018-02-08T17:00:00+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue31530",
      "issue_number": "31530"
    },
    "details": "Python 2.7.14 is vulnerable to a Heap-Buffer-Overflow as well as a Heap-Use-After-Free. Python versions prior to 2.7.14 may also be vulnerable and it appears that Python 2.7.17 and prior may also be vulnerable however this has not been confirmed. The vulnerability lies when multiply threads are handling large amounts of data. In both cases there is essentially a race condition that occurs. For the Heap-Buffer-Overflow, Thread 2 is creating the size for a buffer, but Thread1 is already writing to the buffer without knowing how much to write. So when a large amount of data is being processed, it is very easy to cause memory corruption using a Heap-Buffer-Overflow. As for the Use-After-Free, Thread3->Malloc->Thread1->Free's->Thread2-Re-uses-Free'd Memory. The PSRT has stated that this is not a security vulnerability due to the fact that the attacker must be able to run code, however in some situations, such as function as a service, this vulnerability can potentially be used by an attacker to violate a trust boundary, as such the DWF feels this issue deserves a CVE.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          14
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          8
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          5
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          4
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          15
        ],
        "commits": [
          "dbf52e02f18dac6f5f0a64f78932f3dc6efc056b"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        4
      ],
      [
        3,
        5
      ],
      [
        3,
        6
      ]
    ]
  },
  {
    "id": "PSF-2018-3",
    "cve": "CVE-2018-1060",
    "published": "2018-06-18T14:00:00+00:00",
    "modified": "2020-01-21T21:06:22+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue32981",
      "issue_number": "32981"
    },
    "details": "python before versions 2.7.15, 3.4.9, 3.5.6rc1, 3.6.5rc1 and 3.7.0 is vulnerable to catastrophic backtracking in pop3lib's apop() method. An attacker could use this flaw to cause denial of service.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          14
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          8
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          5
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          4
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          15
        ],
        "commits": [
          "e052d40cea15f582b50947f7d906b39744dc62a2"
        ]
      },
      {
        "version": [
          3,
          4,
          9
        ],
        "commits": [
          "942cc04ae44825ea120e3a19a80c9b348b8194d0"
        ]
      },
      {
        "version": [
          3,
          5,
          6
        ],
        "commits": [
          "937ac1fe069a4dc8471dff205f553d82e724015b"
        ]
      },
      {
        "version": [
          3,
          6,
          5
        ],
        "commits": [
          "c9516754067d71fd7429a25ccfcb2141fc583523"
        ]
      },
      {
        "version": [
          3,
          7,
          0
        ],
        "commits": [
          "0902a2d6b2d1d9dbde36aeaaccf1788ceaa97143"
        ]
      },
      {
        "version": [
          3,
          8,
          0
        ],
        "commits": [
          "0e6c8ee2358a2e23117501826c008842acb835ac"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2018-4",
    "cve": "CVE-2018-1061",
    "published": "2018-06-19T12:00:00+00:00",
    "modified": "2020-01-21T21:06:16+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue32981",
      "issue_number": "32981"
    },
    "details": "python before versions 2.7.15, 3.4.9, 3.5.6rc1, 3.6.5rc1 and 3.7.0 is vulnerable to catastrophic backtracking in the difflib.IS_LINE_JUNK method.  An attacker could use this flaw to cause denial of service.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          14
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          8
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          5
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          4
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          15
        ],
        "commits": [
          "e052d40cea15f582b50947f7d906b39744dc62a2"
        ]
      },
      {
        "version": [
          3,
          4,
          9
        ],
        "commits": [
          "942cc04ae44825ea120e3a19a80c9b348b8194d0"
        ]
      },
      {
        "version": [
          3,
          5,
          6
        ],
        "commits": [
          "937ac1fe069a4dc8471dff205f553d82e724015b"
        ]
      },
      {
        "version": [
          3,
          6,
          5
        ],
        "commits": [
          "c9516754067d71fd7429a25ccfcb2141fc583523"
        ]
      },
      {
        "version": [
          3,
          7,
          0
        ],
        "commits": [
          "0902a2d6b2d1d9dbde36aeaaccf1788ceaa97143"
        ]
      },
      {
        "version": [
          3,
          8,
          0
        ],
        "commits": [
          "0e6c8ee2358a2e23117501826c008842acb835ac"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2018-5",
    "cve": "CVE-2018-14647",
    "published": "2018-09-25T00:00:00+00:00",
    "modified": "2020-07-29T11:06:41+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue34623",
      "issue_number": "34623"
    },
    "details": "Python's elementtree C accelerator failed to initialise Expat's hash salt during initialization. This could make it easy to conduct denial of service attacks against Expat by constructing an XML document that would cause pathological hash collisions in Expat's internal data structures, consuming large amounts CPU and RAM. The vulnerability exists in Python versions 3.7.0, 3.6.0 through 3.6.6, 3.5.0 through 3.5.6, 3.4.0 through 3.4.9, 2.7.0 through 2.7.15.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          15
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          9
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          6
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          6
        ]
      ],
      [
        [
          3,
          7,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          16
        ],
        "commits": [
          "18b20bad75b4ff0486940fba4ec680e96e70f3a2"
        ]
      },
      {
        "version": [
          3,
          4,
          10
        ],
        "commits": [
          "d16eaf36795da48b930b80b20d3805bc27820712"
        ]
      },
      {
        "version": [
          3,
          5,
          7
        ],
        "commits": [
          "41b48e71ac8a71f56694b548f118bd20ce203410"
        ]
      },
      {
        "version": [
          3,
          6,
          7
        ],
        "commits": [
          "f7666e828cc3d5873136473ea36ba2013d624fa1"
        ]
      },
      {
        "version": [
          3,
          7,
          1
        ],
        "commits": [
          "470a435f3b42c9be5fdb7f7b04f3df5663ba7305"
        ]
      },
      {
        "version": [
          3,
          8,
          0
        ],
        "commits": [
          "cb5778f00ce48631c7140f33ba242496aaf7102b"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2018-6",
    "cve": "CVE-2018-20406",
    "published": "2018-12-23T23:00:00+00:00",
    "modified": "2020-10-29T14:32:15+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue34656",
      "issue_number": "34656"
    },
    "details": "Modules/_pickle.c in Python before 3.7.1 has an integer overflow via a large LONG_BINPUT value that is mishandled during a \"resize to twice the size\" attempt. This issue might cause memory exhaustion, but is only relevant if the pickle format is used for serializing tens or hundreds of gigabytes of data. This issue is fixed in: v3.4.10, v3.4.10rc1; v3.5.10, v3.5.10rc1, v3.5.7, v3.5.7rc1, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.7, v3.6.7rc1, v3.6.7rc2, v3.6.8, v3.6.8rc1, v3.6.9, v3.6.9rc1; v3.7.1, v3.7.1rc1, v3.7.1rc2, v3.7.2, v3.7.2rc1, v3.7.3, v3.7.3rc1, v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          15
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          9
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          6
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          6
        ]
      ],
      [
        [
          3,
          7,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          4,
          10
        ],
        "commits": [
          "4b42d575bf0fb01192b3ec54b7e224b238691527"
        ]
      },
      {
        "version": [
          3,
          5,
          7
        ],
        "commits": [
          "ef33dd6036aafbd3f06c1d56e2b1a81dae3da63c"
        ]
      },
      {
        "version": [
          3,
          6,
          7
        ],
        "commits": [
          "71a9c65e74a70b6ed39adc4ba81d311ac1aa2acc"
        ]
      },
      {
        "version": [
          3,
          7,
          1
        ],
        "commits": [
          "ef4306b24c9034d6b37bb034e2ebe82e745d4b77"
        ]
      },
      {
        "version": [
          3,
          8,
          0
        ],
        "commits": [
          "a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        7
      ]
    ]
  },
  {
    "id": "PSF-2018-7",
    "cve": null,
    "published": "2018-09-24T00:00:00+00:00",
    "modified": "0001-01-01T00:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue34791",
      "issue_number": "34791"
    },
    "details": "On two occasions, the xml package uses environment variables to override\nparser / DOM implementations: ``xml.sax package`` and ``xml.dom.domreg``\nmodule. On both occasions, the code should not use env vars to override\nmodule names, when the interpreter is started with flags like ``-E``\nor ``-I``.\n",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          15
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          9
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          6
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          6
        ]
      ],
      [
        [
          3,
          7,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          16
        ],
        "commits": [
          "2546ac8eeb56fc146adea9a03158440a9271714e"
        ]
      },
      {
        "version": [
          3,
          4,
          10
        ],
        "commits": [
          "765d333512e9b58da4a4431595a0e81517ef0443"
        ]
      },
      {
        "version": [
          3,
          5,
          7
        ],
        "commits": [
          "7cd08cf62086a8a2d84fd825dfcd8bfe33bf1986"
        ]
      },
      {
        "version": [
          3,
          6,
          7
        ],
        "commits": [
          "5e808f92ea4eb238b17757526b99f97debf7dd57"
        ]
      },
      {
        "version": [
          3,
          7,
          1
        ],
        "commits": [
          "c119d5948f941d2f528dda3f099e196bd6383000"
        ]
      },
      {
        "version": [
          3,
          8,
          0
        ],
        "commits": [
          "223e501fb9c2b6ae21b96054e20c4c31d94a5d96"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2018-8",
    "cve": null,
    "published": "2018-05-16T00:00:00+00:00",
    "modified": "0001-01-01T00:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue33529",
      "issue_number": "33529"
    },
    "details": "The email folding function enters an infinite loop if a header is longer\nthan the policy maximum line length and contains many non-ASCII characters.\n\nRegression introduced in Python 3.6.4.\n",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          15
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          8
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          5
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          5
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          6,
          9
        ],
        "commits": [
          "516a6a254814d2bc6a90290dfc44d77fdfb4050b"
        ]
      },
      {
        "version": [
          3,
          7,
          4
        ],
        "commits": [
          "2fef5b01e36a17e36fd7e65c4b51f5ede8880dda"
        ]
      },
      {
        "version": [
          3,
          8,
          0
        ],
        "commits": [
          "c1f5667be1e3ec5871560c677402c1252c6018a6"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        7
      ],
      [
        3,
        4
      ],
      [
        3,
        5
      ]
    ]
  },
  {
    "id": "PSF-2019-1",
    "cve": "CVE-2013-1752",
    "published": "2019-06-03T19:04:24+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue16038",
      "issue_number": "16038"
    },
    "details": "The smtplib module doesn't limit the amount of read data in\nits call to readline(). An erroneous or malicious SMTP server can trick the\nsmtplib module to consume large amounts of memory.\n",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          6,
          9
        ],
        "commits": [
          "42faa55124abcbb132c57745dec9e0489ac74406"
        ]
      },
      {
        "version": [
          2,
          7,
          2
        ],
        "commits": [
          "d7b6ac66c1b81d13f2efa8d9ebba69e17c158c0a",
          "ff1bbba92aad261df1ebd8fd8cc189c104e113b0"
        ]
      },
      {
        "version": [
          2,
          7,
          6
        ],
        "commits": [
          "2585e1e48abb3013abeb8a1fe9dccb5f79ac4091"
        ]
      },
      {
        "version": [
          2,
          7,
          9
        ],
        "commits": [
          "dabfc56b57f5086eb5522d8e6cd7670c62d2482d",
          "faad6bbea6c86e30c770eb0a3648e2cd52b2e55e"
        ]
      },
      {
        "version": [
          2,
          7,
          16
        ],
        "commits": [
          "16d63202af35dadd652a5e3eae687ea709e95b11"
        ]
      },
      {
        "version": [
          3,
          2,
          6
        ],
        "commits": [
          "210ee47e3340d8e689d8cce584e7c918d368f16b",
          "b3ac84322fe6dd542aa755779cdbc155edca8064",
          "c9cb18d3f7e5bf03220c213183ff0caa75905bdd",
          "eaca8616ab0e219ebb5cf37d495f4bf336ec0f5e"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2019-2",
    "cve": "CVE-2016-1000110",
    "published": "2019-11-27T16:54:34+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue27568",
      "issue_number": "27568"
    },
    "details": "The CGIHandler class in Python before 2.7.12 does not protect against the HTTP_PROXY variable name clash in a CGI script, which could allow a remote attacker to redirect HTTP requests.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          12
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          13
        ],
        "commits": [
          "75d7b615ba70fc5759d16dee95bbd8f0474d8a9c"
        ]
      },
      {
        "version": [
          3,
          3,
          7
        ],
        "commits": [
          "4cbb23f8f278fd1f71dcd5968aa0b3f0b4f3bd5d"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        5
      ]
    ]
  },
  {
    "id": "PSF-2019-3",
    "cve": "CVE-2019-10160",
    "published": "2019-06-07T17:50:33+00:00",
    "modified": "2020-08-22T16:06:12+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue36742",
      "issue_number": "36742"
    },
    "details": "A security regression of CVE-2019-9636 was discovered in python since commit d537ab0ff9767ef024f26246899728f0116b1ec3 affecting versions 2.7, 3.5, 3.6, 3.7 and from v3.8.0a4 through v3.8.0b1, which still allows an attacker to exploit CVE-2019-9636 by abusing the user and password parts of a URL. When an application parses user-supplied URLs to store cookies, authentication credentials, or other kind of information, it is possible for an attacker to provide specially crafted URLs to make the application locate host-related information (e.g. cookies, authentication data) and send them to a different host than where it should, unlike if the URLs had been correctly parsed. The result of an attack may vary based on the application.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          16
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          7
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          8
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          17
        ],
        "commits": [
          "f61599b050c621386a3fc6bc480359e2d3bb93de"
        ]
      },
      {
        "version": [
          3,
          5,
          8
        ],
        "commits": [
          "4655d576141ee56a69d2052431c636858fcb916a"
        ]
      },
      {
        "version": [
          3,
          6,
          9
        ],
        "commits": [
          "fd1771dbdd28709716bd531580c40ae5ed814468"
        ]
      },
      {
        "version": [
          3,
          7,
          4
        ],
        "commits": [
          "250b62acc59921d399f0db47db3b462cd6037e09"
        ]
      },
      {
        "version": [
          3,
          8,
          0
        ],
        "commits": [
          "8d0ef0b5edeae52960c7ed05ae8a12388324f87e"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2019-4",
    "cve": "CVE-2019-12900",
    "published": "2019-06-19T22:07:57+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue44549",
      "issue_number": "44549"
    },
    "details": "BZ2_decompress in decompress.c in bzip2 through 1.0.6 has an out-of-bounds write when there are many selectors.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          16
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          7
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          8
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          7,
          13
        ],
        "commits": [
          "4a3c610cd635f14747cf02c77908e80620aae6ea"
        ]
      },
      {
        "version": [
          3,
          8,
          13
        ],
        "commits": [
          "6649519e67841b1aa12672f1d9b5cb24494f6196"
        ]
      },
      {
        "version": [
          3,
          9,
          11
        ],
        "commits": [
          "e1639f361ee0dfbf08bb8538839d3d557c1a995c"
        ]
      },
      {
        "version": [
          3,
          10,
          3
        ],
        "commits": [
          "58d576a43cb1800dd68f06a429d7d41f746a8c01"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        7
      ],
      [
        3,
        5
      ],
      [
        3,
        6
      ]
    ]
  },
  {
    "id": "PSF-2019-5",
    "cve": "CVE-2019-16056",
    "published": "2019-09-06T17:24:35+00:00",
    "modified": "2020-08-22T16:06:09+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue34155",
      "issue_number": "34155"
    },
    "details": "An issue was discovered in Python through 2.7.16, 3.x through 3.5.7, 3.6.x through 3.6.9, and 3.7.x through 3.7.4. The email module wrongly parses email addresses that contain multiple @ characters. An application that uses the email module and implements some kind of checks on the From/To headers of a message could be tricked into accepting an email address that should be denied. An attack may be the same as in CVE-2019-11340; however, this CVE applies to Python more generally.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          16
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          7
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          9
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          4
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          17
        ],
        "commits": [
          "4cbcd2f8c4e12b912e4d21fd892eedf7a3813d8e"
        ]
      },
      {
        "version": [
          3,
          5,
          8
        ],
        "commits": [
          "063eba280a11d3c9a5dd9ee5abe4de640907951b"
        ]
      },
      {
        "version": [
          3,
          6,
          10
        ],
        "commits": [
          "13a19139b5e76175bc95294d54afc9425e4f36c9"
        ]
      },
      {
        "version": [
          3,
          7,
          5
        ],
        "commits": [
          "c48d606adcef395e59fd555496c42203b01dd3e8"
        ]
      },
      {
        "version": [
          3,
          8,
          0
        ],
        "commits": [
          "217077440a6938a0b428f67cfef6e053c4f8673c"
        ]
      },
      {
        "version": [
          3,
          9,
          0
        ],
        "commits": [
          "8cb65d1381b027f0b09ee36bfed7f35bb4dec9a9"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2019-6",
    "cve": "CVE-2019-16935",
    "published": "2019-09-28T01:33:02+00:00",
    "modified": "2021-04-17T21:06:13+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue38243",
      "issue_number": "38243"
    },
    "details": "The documentation XML-RPC server in Python through 2.7.16, 3.x through 3.6.9, and 3.7.x through 3.7.4 has XSS via the server_title field. This occurs in Lib/DocXMLRPCServer.py in Python 2.x, and in Lib/xmlrpc/server.py in Python 3.x. If set_server_title is called with untrusted input, arbitrary JavaScript can be delivered to clients that visit the http URL for this server.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          16
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          7
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          9
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          4
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          17
        ],
        "commits": [
          "8eb64155ff26823542ccf0225b3d57b6ae36ea89"
        ]
      },
      {
        "version": [
          3,
          5,
          8
        ],
        "commits": [
          "3fe1b19265b55c290fc956e9aafcf661803782de"
        ]
      },
      {
        "version": [
          3,
          6,
          10
        ],
        "commits": [
          "1698cacfb924d1df452e78d11a4bf81ae7777389"
        ]
      },
      {
        "version": [
          3,
          7,
          5
        ],
        "commits": [
          "39a0c7555530e31c6941a78da19b6a5b61170687"
        ]
      },
      {
        "version": [
          3,
          8,
          0
        ],
        "commits": [
          "6447b9f9bd27e1f6b04cef674dd3a7ab27bf4f28"
        ]
      },
      {
        "version": [
          3,
          9,
          0
        ],
        "commits": [
          "e8650a4f8c7fb76f570d4ca9c1fbe44e91c8dfaa"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2019-7",
    "cve": "CVE-2019-18348",
    "published": "2019-10-23T16:31:22+00:00",
    "modified": "2020-11-02T18:52:05+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue38576",
      "issue_number": "38576"
    },
    "details": "An issue was discovered in urllib2 in Python 2.x through 2.7.17 and urllib in Python 3.x through 3.8.0. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the host component of a URL) followed by an HTTP header. This is similar to the CVE-2019-9740 query string issue and the CVE-2019-9947 path string issue. (This is not exploitable when glibc has CVE-2016-10739 fixed.). This is fixed in: v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1; v3.6.11, v3.6.11rc1, v3.6.12; v3.7.8, v3.7.8rc1, v3.7.9; v3.8.3, v3.8.3rc1, v3.8.4, v3.8.4rc1, v3.8.5, v3.8.6, v3.8.6rc1.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          17
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          7
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          9
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          5
        ]
      ],
      [
        [
          3,
          8,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          18
        ],
        "commits": [
          "e176e0c105786e9f476758eb5438c57223b65e7f"
        ]
      },
      {
        "version": [
          3,
          5,
          10
        ],
        "commits": [
          "09d8172837b6985c4ad90ee025f6b5a554a9f0ac"
        ]
      },
      {
        "version": [
          3,
          6,
          11
        ],
        "commits": [
          "83fc70159b24f5b11a5ef87c9b05c2cf4c7faeba"
        ]
      },
      {
        "version": [
          3,
          7,
          8
        ],
        "commits": [
          "34f85af3229f86c004a954c3f261ceea1f5e9f95"
        ]
      },
      {
        "version": [
          3,
          8,
          3
        ],
        "commits": [
          "ff69c9d12c1b06af58e5eae5db4630cedd94740e"
        ]
      },
      {
        "version": [
          3,
          9,
          0
        ],
        "commits": [
          "9165addc22d05e776a54319a8531ebd0b2fe01ef"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2019-8",
    "cve": "CVE-2019-5010",
    "published": "2019-10-31T20:05:57+00:00",
    "modified": "2022-04-19T17:32:41+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue35746",
      "issue_number": "35746"
    },
    "details": "An exploitable denial-of-service vulnerability exists in the X509 certificate parser of Python.org Python 2.7.11 / 3.6.6. A specially crafted X509 certificate can cause a NULL pointer dereference, resulting in a denial of service. An attacker can initiate or accept TLS connections using crafted certificates to trigger this vulnerability.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          15
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          6
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          8
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          16
        ],
        "commits": [
          "06b15424b0dcacb1c551b2a36e739fffa8d0c595"
        ]
      },
      {
        "version": [
          3,
          4,
          10
        ],
        "commits": [
          "6c655ce34ae54adb8eef22b73108e22cc381cb8d"
        ]
      },
      {
        "version": [
          3,
          5,
          7
        ],
        "commits": [
          "efec7631edf3b9480dc3988c97ffef94df8800da"
        ]
      },
      {
        "version": [
          3,
          6,
          9
        ],
        "commits": [
          "216a4d83c3b72f4fdcd81b588dc3f42cc461739a"
        ]
      },
      {
        "version": [
          3,
          7,
          3
        ],
        "commits": [
          "be5de958e9052e322b0087c6dba81cdad0c3e031"
        ]
      },
      {
        "version": [
          3,
          8,
          0
        ],
        "commits": [
          "a37f52436f9aa4b9292878b72f3ff1480e2606c3"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2019-9",
    "cve": "CVE-2019-9636",
    "published": "2019-03-08T21:00:00+00:00",
    "modified": "2022-07-25T16:13:04+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue36216",
      "issue_number": "36216"
    },
    "details": "Python 2.7.x through 2.7.16 and 3.x through 3.7.2 is affected by: Improper Handling of Unicode Encoding (with an incorrect netloc) during NFKC normalization. The impact is: Information disclosure (credentials, cookies, etc. that are cached against a given hostname). The components are: urllib.parse.urlsplit, urllib.parse.urlparse. The attack vector is: A specially crafted URL could be incorrectly parsed to locate cookies or authentication data and send that information to a different host than when parsed correctly. This is fixed in: v2.7.17, v2.7.17rc1, v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1, v3.5.7, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.9, v3.6.9rc1; v3.7.3, v3.7.3rc1, v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          16
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          9
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          6
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          8
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          17
        ],
        "commits": [
          "e37ef41289b77e0f0bb9a6aedb0360664c55bdd5"
        ]
      },
      {
        "version": [
          3,
          5,
          7
        ],
        "commits": [
          "c0d95113b070799679bcb9dc49d4960d82e8bb08"
        ]
      },
      {
        "version": [
          3,
          6,
          9
        ],
        "commits": [
          "23fc0416454c4ad5b9b23d520fbe6d89be3efc24"
        ]
      },
      {
        "version": [
          3,
          7,
          3
        ],
        "commits": [
          "daad2c482c91de32d8305abbccc76a5de8b3a8be"
        ]
      },
      {
        "version": [
          3,
          8,
          0
        ],
        "commits": [
          "16e6f7dee7f02bb81aa6b385b982dcdda5b99286"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        4
      ]
    ]
  },
  {
    "id": "PSF-2019-10",
    "cve": "CVE-2019-9740",
    "published": "2019-03-13T03:00:00+00:00",
    "modified": "2022-07-25T16:13:15+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue30458",
      "issue_number": "30458"
    },
    "details": "An issue was discovered in urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the query string after a ? character) followed by an HTTP header or a Redis command. This is fixed in: v2.7.17, v2.7.17rc1, v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.9, v3.6.9rc1; v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          16
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          9
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          6
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          8
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          17
        ],
        "commits": [
          "bb8071a4cae5ab3fe321481dd3d73662ffb26052"
        ]
      },
      {
        "version": [
          3,
          5,
          8
        ],
        "commits": [
          "afe3a4975cf93c97e5d6eb8800e48f368011d37a"
        ]
      },
      {
        "version": [
          3,
          6,
          9
        ],
        "commits": [
          "c50d437e942d4c4c45c8cd76329b05340c02eb31"
        ]
      },
      {
        "version": [
          3,
          7,
          4
        ],
        "commits": [
          "7e200e0763f5b71c199aaf98bd5588f291585619"
        ]
      },
      {
        "version": [
          3,
          8,
          0
        ],
        "commits": [
          "c4e671eec20dfcb29b18596a89ef075f826c9f96"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        4
      ]
    ]
  },
  {
    "id": "PSF-2019-11",
    "cve": "CVE-2019-9947",
    "published": "2019-03-23T17:06:47+00:00",
    "modified": "2021-02-04T12:06:08+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue30458",
      "issue_number": "30458"
    },
    "details": "An issue was discovered in urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the path component of a URL that lacks a ? character) followed by an HTTP header or a Redis command. This is similar to the CVE-2019-9740 query string issue. This is fixed in: v2.7.17, v2.7.17rc1, v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.9, v3.6.9rc1; v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          16
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          7
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          8
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          17
        ],
        "commits": [
          "bb8071a4cae5ab3fe321481dd3d73662ffb26052"
        ]
      },
      {
        "version": [
          3,
          5,
          8
        ],
        "commits": [
          "afe3a4975cf93c97e5d6eb8800e48f368011d37a"
        ]
      },
      {
        "version": [
          3,
          6,
          9
        ],
        "commits": [
          "c50d437e942d4c4c45c8cd76329b05340c02eb31"
        ]
      },
      {
        "version": [
          3,
          7,
          4
        ],
        "commits": [
          "7e200e0763f5b71c199aaf98bd5588f291585619"
        ]
      },
      {
        "version": [
          3,
          8,
          0
        ],
        "commits": [
          "c4e671eec20dfcb29b18596a89ef075f826c9f96"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2019-12",
    "cve": "CVE-2019-9948",
    "published": "2019-03-23T17:07:08+00:00",
    "modified": "2020-08-22T16:06:15+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue35907",
      "issue_number": "35907"
    },
    "details": "urllib in Python 2.x through 2.7.16 supports the local_file: scheme, which makes it easier for remote attackers to bypass protection mechanisms that blacklist file: URIs, as demonstrated by triggering a urllib.urlopen('local_file:///etc/passwd') call.",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          16
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          7
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          8
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          17
        ],
        "commits": [
          "b15bde8058e821b383d81fcae68b335a752083ca"
        ]
      },
      {
        "version": [
          3,
          5,
          8
        ],
        "commits": [
          "4fe82a8eef7aed60de05bfca0f2c322730ea921e"
        ]
      },
      {
        "version": [
          3,
          6,
          9
        ],
        "commits": [
          "4f06dae5d8d4400ba38d8502da620f07d4a5696e"
        ]
      },
      {
        "version": [
          3,
          7,
          4
        ],
        "commits": [
          "34bab215596671d0dec2066ae7d7450cd73f638b"
        ]
      },
      {
        "version": [
          3,
          8,
          0
        ],
        "commits": [
          "0c2b6a3943aa7b022e8eb4bfd9bffcddebf9a587"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2019-13",
    "cve": null,
    "published": "2019-07-01T00:00:00+00:00",
    "modified": "0001-01-01T00:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue37463",
      "issue_number": "37463"
    },
    "details": "``inet_aton()`` accepts trailing characters after a valid IP.  Because of\nthat, Python ``ssl.match_hostname('1.1.1.1 ; this should not work but does')``\nsucceeded when it should fail.\n\nThe issue was introduced in `bpo-32819\n<https://bugs.python.org/issue32819>`_ by `commit aef1283b\n<https://github.com/python/cpython/commit/aef1283ba428e33397d87cee3c54a5110861552d>`_.\nOnly Python 3.7 and newer are affected. It's a potential security bug\nalthough **low severity**. For one Python 3.7 and newer **no longer use**\n``ssl.match_hostname()`` to verify hostnames and IP addresses of a\ncertificate: **matching is performed by OpenSSL**.\n\nIt should not possible to register a x509 certificate with a hostname with\nspaces.\n\nThe glibc function ``inet_aton()`` accepts input as valid if said input is\na IPv4 address followed by zero or more characters that are valid\nwhite-space as decided by ``isspace()``, with the rest of the string after\nthe first white-space being ignored. As ``'\\r'`` is a valid white-space\ncharacter the rest of the string is ignored (including the ``'\\r'``). See\n`glibc bug 24111: Deprecate inet_addr, inet_aton\n<https://sourceware.org/bugzilla/show_bug.cgi?id=24111>`_.\n",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          16
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          7
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          8
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          7,
          4
        ],
        "commits": [
          "070fae6d0ff49e63bfd5f2bdc66f8eb1df3b6557"
        ]
      },
      {
        "version": [
          3,
          8,
          0
        ],
        "commits": [
          "3cba3d3c55f230a59174a0dfcafb1d4685269e60"
        ]
      },
      {
        "version": [
          3,
          9,
          0
        ],
        "commits": [
          "477b1b25768945621d466a8b3f0739297a842439"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        7
      ],
      [
        3,
        5
      ],
      [
        3,
        6
      ]
    ]
  },
  {
    "id": "PSF-2019-14",
    "cve": null,
    "published": "2019-11-14T00:00:00+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue38804",
      "issue_number": "38804"
    },
    "details": "The regex ``http.cookiejar.LOOSE_HTTP_DATE_RE`` is vulnerable to regular\nexpression denial of service (\"REDoS\"). ``LOOSE_HTTP_DATE_RE.match()`` is\ncalled when using ``http.cookiejar.CookieJar`` to parse ``Set-Cookie``\nheaders returned by a HTTP server. Processing a response from a malicious\nHTTP server can lead to extreme CPU usage and execution will be blocked\nfor a long time.\n",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          17
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          9
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          9
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          5
        ]
      ],
      [
        [
          3,
          8,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          18
        ],
        "commits": [
          "e6499033032d5b647e43a3b49da0c1c64b151743"
        ]
      },
      {
        "version": [
          3,
          5,
          10
        ],
        "commits": [
          "55a6a16a46239a71b635584e532feb8b17ae7fdf"
        ]
      },
      {
        "version": [
          3,
          6,
          10
        ],
        "commits": [
          "0716056c49e9505041e30386dad9b2e788f67aaf"
        ]
      },
      {
        "version": [
          3,
          7,
          6
        ],
        "commits": [
          "cb6085138a845f8324adc011b65754acc2086cc0"
        ]
      },
      {
        "version": [
          3,
          8,
          1
        ],
        "commits": [
          "a1e1be4c4969c7c20c8c958e5ab5279ae6a66a16"
        ]
      },
      {
        "version": [
          3,
          9,
          0
        ],
        "commits": [
          "1b779bfb8593739b11cbb988ef82a883ec9d077e"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2019-15",
    "cve": null,
    "published": "2019-11-30T00:00:00+00:00",
    "modified": "0001-01-01T00:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue38945",
      "issue_number": "38945"
    },
    "details": "Filenames passed to the UU encoding methods (uu.py and uu_codec.py) that\ncontain a newline character will overflow data into the UU content section.\nThis can potentially be used to inject replace or corrupt data content in a\nfile during the decode process.\n\nThe fix removes newline characters from filenames.\n",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          17
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          9
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          9
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          5
        ]
      ],
      [
        [
          3,
          8,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          18
        ],
        "commits": [
          "a016d4e32cc9faa48105d00db275439c3dc93559"
        ]
      },
      {
        "version": [
          3,
          5,
          10
        ],
        "commits": [
          "8835f465fa94f114dcf865429c0410821d365dae"
        ]
      },
      {
        "version": [
          3,
          6,
          10
        ],
        "commits": [
          "30afc91f5e70cf4748ffac77a419ba69ebca6f6a"
        ]
      },
      {
        "version": [
          3,
          7,
          6
        ],
        "commits": [
          "87f2d261ee1c63ed39517355833d087c5a78b4bf"
        ]
      },
      {
        "version": [
          3,
          8,
          1
        ],
        "commits": [
          "8859fc629474ab1ca7eb2e67aec538097c327e58"
        ]
      },
      {
        "version": [
          3,
          9,
          0
        ],
        "commits": [
          "a62ad4730c9b575f140f24074656c0257c86a09a"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2019-16",
    "cve": null,
    "published": "2019-12-17T00:00:00+00:00",
    "modified": "0001-01-01T00:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue39073",
      "issue_number": "39073"
    },
    "details": "It is possible to inject email headers using CR or LF character.\n\nThe fix disallows CR and LF characters in ``email.headerregistry.Address``\narguments to guard against header injection attacks.\n",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          17
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          9
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          9
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          5
        ]
      ],
      [
        [
          3,
          8,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          5,
          10
        ],
        "commits": [
          "f91a0b6df14d6c5133fe3d5889fad7d84fc0c046"
        ]
      },
      {
        "version": [
          3,
          6,
          11
        ],
        "commits": [
          "7df32f844efed33ca781a016017eab7050263b90"
        ]
      },
      {
        "version": [
          3,
          7,
          8
        ],
        "commits": [
          "a93bf82980d7c02217a088bafa193f32a4d13abb"
        ]
      },
      {
        "version": [
          3,
          8,
          4
        ],
        "commits": [
          "75635c6095bcfbb9fccc239115d3d03ae20a307f"
        ]
      },
      {
        "version": [
          3,
          9,
          0
        ],
        "commits": [
          "614f17211c5fc0e5b828be1d3320661d1038fe8f"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        2,
        7
      ]
    ]
  },
  {
    "id": "PSF-2019-17",
    "cve": null,
    "published": "2019-01-03T00:00:00+00:00",
    "modified": "0001-01-01T00:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue35647",
      "issue_number": "35647"
    },
    "details": "Cookies of ``example.com`` with ``path=/any`` were sent to\n``example.com/anybad/`` while using a cookiejar with\n`http.cookiejar.DefaultCookiePolicy` policy. The code did not check for\nthe first non-matching character in prefix match to be a slash.\n",
    "affected_versions": [
      [
        [
          2,
          7,
          1
        ],
        [
          2,
          7,
          15
        ]
      ],
      [
        [
          3,
          4,
          0
        ],
        [
          3,
          4,
          9
        ]
      ],
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          6
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          8
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          17
        ],
        "commits": [
          "ee15aa2b8501718cb77e339381f72409a416f801"
        ]
      },
      {
        "version": [
          3,
          4,
          10
        ],
        "commits": [
          "e260f092cd0d8975c777e73ca6fb549d59b5d452"
        ]
      },
      {
        "version": [
          3,
          5,
          7
        ],
        "commits": [
          "382981b25092b5e9285f1e4894142af1e8f2ca86"
        ]
      },
      {
        "version": [
          3,
          6,
          9
        ],
        "commits": [
          "5565b1db6f37f244890369e0d68a3e906aca28b9"
        ]
      },
      {
        "version": [
          3,
          7,
          3
        ],
        "commits": [
          "97c7d78fda49e03fc773c171ce0c736d02bb73f5"
        ]
      },
      {
        "version": [
          3,
          8,
          0
        ],
        "commits": [
          "0e1f1f01058bd4a9b98cfe443214adecc019a38c"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2020-1",
    "cve": "CVE-2013-1753",
    "published": "2020-03-11T16:46:35+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue16043",
      "issue_number": "16043"
    },
    "details": "The gzip_decode function in the xmlrpc client library in Python 3.4 and earlier allows remote attackers to cause a denial of service (memory consumption) via a crafted HTTP request.",
    "affected_versions": [],
    "fixed_in": [
      {
        "version": [
          2,
          7,
          9
        ],
        "commits": [
          "9e8f523c5b1c354097753084054eadf14d33238d"
        ]
      },
      {
        "version": [
          3,
          3,
          7
        ],
        "commits": [
          "4e9cefaf86035f8014e09049328d197b6506532f"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2020-2",
    "cve": "CVE-2019-20907",
    "published": "2020-07-13T00:00:00+00:00",
    "modified": "2023-05-24T00:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue39017",
      "issue_number": "39017"
    },
    "details": "In Lib/tarfile.py in Python through 3.8.3, an attacker is able to craft a TAR archive leading to an infinite loop when opened by tarfile.open, because _proc_pax lacks header validation.",
    "affected_versions": [
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          9
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          11
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          8
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          5,
          10
        ],
        "commits": [
          "cac9ca8ed99bd98f4c0dcd1913a146192bf5ee84"
        ]
      },
      {
        "version": [
          3,
          6,
          12
        ],
        "commits": [
          "47a2955589bdb1a114d271496ff803ad73f954b8"
        ]
      },
      {
        "version": [
          3,
          7,
          9
        ],
        "commits": [
          "79c6b602efc9a906c8496f3d5f4d54c54b48fa06"
        ]
      },
      {
        "version": [
          3,
          8,
          5
        ],
        "commits": [
          "c55479556db015f48fc8bbca17f64d3e65598559"
        ]
      },
      {
        "version": [
          3,
          9,
          0
        ],
        "commits": [
          "f3232294ee695492f43d424cc6969d018d49861d"
        ]
      },
      {
        "version": [
          3,
          10,
          0
        ],
        "commits": [
          "5a8d121a1f3ef5ad7c105ee378cc79a3eac0c7d4"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2020-3",
    "cve": "CVE-2020-14422",
    "published": "2020-06-18T00:00:00+00:00",
    "modified": "2023-05-16T00:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue41004",
      "issue_number": "41004"
    },
    "details": "Lib/ipaddress.py in Python through 3.8.3 improperly computes hash values in the IPv4Interface and IPv6Interface classes, which might allow a remote attacker to cause a denial of service if an application is affected by the performance of a dictionary containing IPv4Interface or IPv6Interface objects, and this attacker can cause many dictionary entries to be created. This is fixed in: v3.5.10, v3.5.10rc1; v3.6.12; v3.7.9; v3.8.4, v3.8.4rc1, v3.8.5, v3.8.6, v3.8.6rc1; v3.9.0, v3.9.0b4, v3.9.0b5, v3.9.0rc1, v3.9.0rc2.",
    "affected_versions": [
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          9
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          10
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          7
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          5,
          10
        ],
        "commits": [
          "11d258ceafdf60ab3840f9a5700f2d0ad3e2e2d1"
        ]
      },
      {
        "version": [
          3,
          6,
          12
        ],
        "commits": [
          "cfc7ff8d05f7a949a88b8a8dd506fb5c1c30d3e9"
        ]
      },
      {
        "version": [
          3,
          7,
          9
        ],
        "commits": [
          "b98e7790c77a4378ec4b1c71b84138cb930b69b7"
        ]
      },
      {
        "version": [
          3,
          8,
          4
        ],
        "commits": [
          "dc8ce8ead182de46584cc1ed8a8c51d48240cbd5"
        ]
      },
      {
        "version": [
          3,
          9,
          0
        ],
        "commits": [
          "9a646aa82dfa62d70ca2a99ada901ee6cf9f82bd"
        ]
      },
      {
        "version": [
          3,
          10,
          0
        ],
        "commits": [
          "b30ee26e366bf509b7538d79bfec6c6d38d53f28"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2020-4",
    "cve": "CVE-2020-15523",
    "published": "2020-07-04T22:54:00+00:00",
    "modified": "2021-03-12T12:06:36+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue29778",
      "issue_number": "29778"
    },
    "details": "In Python 3.6 through 3.6.10, 3.7 through 3.7.8, 3.8 through 3.8.4rc1, and 3.9 through 3.9.0b4 on Windows, a Trojan horse python3.dll might be used in cases where CPython is embedded in a native application. This occurs because python3X.dll may use an invalid search path for python3.dll loading (after Py_SetPath has been used). NOTE: this issue CANNOT occur when using python.exe from a standard (non-embedded) Python installation on Windows.",
    "affected_versions": [
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          9
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          11
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          8
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          5,
          10
        ],
        "commits": [
          "f205f1000a2d7f8b044caf281041b3705f293480"
        ]
      },
      {
        "version": [
          3,
          6,
          12
        ],
        "commits": [
          "46cbf6148a46883110883488d3e9febbe46ba861"
        ]
      },
      {
        "version": [
          3,
          7,
          9
        ],
        "commits": [
          "110dd153662a13b8ae1bb06348e5b1f118ab26d7"
        ]
      },
      {
        "version": [
          3,
          8,
          4
        ],
        "commits": [
          "aa7f7756149a10c64d01f583b71e91814db886ab"
        ]
      },
      {
        "version": [
          3,
          9,
          0
        ],
        "commits": [
          "4981fe36c7477303de830e8dca929a02caaaffe4"
        ]
      },
      {
        "version": [
          3,
          10,
          0
        ],
        "commits": [
          "dcbaa1b49cd9062fb9ba2b9d49555ac6cd8c60b5"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2020-5",
    "cve": "CVE-2020-26116",
    "published": "2020-09-27T00:00:00+00:00",
    "modified": "2023-05-24T00:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue39603",
      "issue_number": "39603"
    },
    "details": "http.client in Python 3.x before 3.5.10, 3.6.x before 3.6.12, 3.7.x before 3.7.9, and 3.8.x before 3.8.5 allows CRLF injection if the attacker controls the HTTP request method, as demonstrated by inserting CR and LF control characters in the first argument of HTTPConnection.request.",
    "affected_versions": [
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          9
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          11
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          8
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          4
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          5,
          10
        ],
        "commits": [
          "524b8de630036a29ca340bc2ae6fd6dc7dda8f40"
        ]
      },
      {
        "version": [
          3,
          6,
          12
        ],
        "commits": [
          "f02de961b9f19a5db0ead56305fe0057a78787ae"
        ]
      },
      {
        "version": [
          3,
          7,
          9
        ],
        "commits": [
          "ca75fec1ed358f7324272608ca952b2d8226d11a"
        ]
      },
      {
        "version": [
          3,
          8,
          5
        ],
        "commits": [
          "668d321476d974c4f51476b33aaca870272523bf"
        ]
      },
      {
        "version": [
          3,
          9,
          0
        ],
        "commits": [
          "27b811057ff5e93b68798e278c88358123efdc71"
        ]
      },
      {
        "version": [
          3,
          10,
          0
        ],
        "commits": [
          "8ca8a2e8fb068863c1138f07e3098478ef8be12e"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2020-6",
    "cve": "CVE-2020-27619",
    "published": "2020-10-22T02:47:40+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue41944",
      "issue_number": "41944"
    },
    "details": "In Python 3 through 3.9.0, the Lib/test/multibytecodec_support.py CJK codec tests call eval() on content retrieved via HTTP.",
    "affected_versions": [
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          12
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          9
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          6
        ]
      ],
      [
        [
          3,
          9,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          6,
          13
        ],
        "commits": [
          "e912e945f2960029d039d3390ea08835ad39374b"
        ]
      },
      {
        "version": [
          3,
          7,
          10
        ],
        "commits": [
          "43e523103886af66d6c27cd72431b5d9d14cd2a9"
        ]
      },
      {
        "version": [
          3,
          8,
          7
        ],
        "commits": [
          "6c6c256df3636ff6f6136820afaefa5a10a3ac33"
        ]
      },
      {
        "version": [
          3,
          9,
          1
        ],
        "commits": [
          "b664a1df4ee71d3760ab937653b10997081b1794"
        ]
      },
      {
        "version": [
          3,
          10,
          0
        ],
        "commits": [
          "2ef5caa58febc8968e670e39e3d37cf8eef3cab8"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2020-7",
    "cve": "CVE-2020-8315",
    "published": "2020-01-28T18:35:58+00:00",
    "modified": "2020-01-28T18:35:58+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue39401",
      "issue_number": "39401"
    },
    "details": "In Python (CPython) 3.6 through 3.6.10, 3.7 through 3.7.6, and 3.8 through 3.8.1, an insecure dependency load upon launch on Windows 7 may result in an attacker's copy of api-ms-win-core-path-l1-1-0.dll being loaded and used instead of the system's copy. Windows 8 and later are unaffected.",
    "affected_versions": [
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          9
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          10
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          6
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          1
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          6,
          11
        ],
        "commits": [
          "51332c467ed2e07a191f903d554d0c54248e4d88"
        ]
      },
      {
        "version": [
          3,
          7,
          7
        ],
        "commits": [
          "561c59777c8426fde0ef48b57cf02eddaeb2a5b8"
        ]
      },
      {
        "version": [
          3,
          8,
          2
        ],
        "commits": [
          "ad4a20b87d79a619ffbdea3f26848780899494e5"
        ]
      },
      {
        "version": [
          3,
          9,
          0
        ],
        "commits": [
          "6a65eba44bfd82ccc8bed4b5c6dd6637549955d5"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        5
      ]
    ]
  },
  {
    "id": "PSF-2020-8",
    "cve": "CVE-2020-8492",
    "published": "2020-01-30T00:00:00+00:00",
    "modified": "2023-05-24T00:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue38826",
      "issue_number": "38826"
    },
    "details": "Python 2.7 through 2.7.17, 3.5 through 3.5.9, 3.6 through 3.6.10, 3.7 through 3.7.6, and 3.8 through 3.8.1 allows an HTTP server to conduct Regular Expression Denial of Service (ReDoS) attacks against a client because of urllib.request.AbstractBasicAuthHandler catastrophic backtracking.",
    "affected_versions": [
      [
        [
          3,
          5,
          0
        ],
        [
          3,
          5,
          9
        ]
      ],
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          10
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          6
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          1
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          5,
          10
        ],
        "commits": [
          "37fe316479e0b6906a74b0c0a5e495c55037fdfd"
        ]
      },
      {
        "version": [
          3,
          6,
          11
        ],
        "commits": [
          "69cdeeb93e0830004a495ed854022425b93b3f3e"
        ]
      },
      {
        "version": [
          3,
          7,
          8
        ],
        "commits": [
          "b57a73694e26e8b2391731b5ee0b1be59437388e"
        ]
      },
      {
        "version": [
          3,
          8,
          3
        ],
        "commits": [
          "ea9e240aa02372440be8024acb110371f69c9d41"
        ]
      },
      {
        "version": [
          3,
          9,
          0
        ],
        "commits": [
          "0b297d4ff1c0e4480ad33acae793fbaf4bf015b4"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2021-1",
    "cve": "CVE-2021-23336",
    "published": "2021-02-15T00:00:00+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": {
      "name": "MEDIUM",
      "score": 5.9,
      "version": "3.1"
    },
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue42967",
      "issue_number": "42967"
    },
    "details": "The package python/cpython from 0 and before 3.6.13, from 3.7.0 and before 3.7.10, from 3.8.0 and before 3.8.8, from 3.9.0 and before 3.9.2 are vulnerable to Web Cache Poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a vector called parameter cloaking. When the attacker can separate query parameters using a semicolon (;), they can cause a difference in the interpretation of the request between the proxy (running with default configuration) and the server. This can result in malicious requests being cached as completely safe ones, as the proxy would usually not see the semicolon as a separator, and therefore would not include it in a cache key of an unkeyed parameter.",
    "affected_versions": [
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          12
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          9
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          7
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          1
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          6,
          13
        ],
        "commits": [
          "5c17dfc5d70ce88be99bc5769b91ce79d7a90d61"
        ]
      },
      {
        "version": [
          3,
          7,
          10
        ],
        "commits": [
          "d0d4d30882fe3ab9b1badbecf5d15d94326fd13e"
        ]
      },
      {
        "version": [
          3,
          8,
          8
        ],
        "commits": [
          "e3110c3cfbb7daa690d54d0eff6c264c870a71bf"
        ]
      },
      {
        "version": [
          3,
          9,
          2
        ],
        "commits": [
          "c9f07813ab8e664d8c34413c4fc2d4f86c061a92"
        ]
      },
      {
        "version": [
          3,
          10,
          0
        ],
        "commits": [
          "fcbe0cb04d35189401c0c880ebfb4311e952d776"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2021-2",
    "cve": "CVE-2021-29921",
    "published": "2021-05-06T00:00:00+00:00",
    "modified": "2023-05-03T00:00:00+00:00",
    "severity": null,
    "issue": null,
    "details": "In Python before 3,9,5, the ipaddress library mishandles leading zero characters in the octets of an IP address string. This (in some situations) allows attackers to bypass access control that is based on IP addresses.",
    "affected_versions": [
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          13
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          10
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          10
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          4
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          8,
          12
        ],
        "commits": [
          "03dd89d62413c4a92831ed1b36e2ae8983bcb2d4"
        ]
      },
      {
        "version": [
          3,
          9,
          5
        ],
        "commits": [
          "5374fbc31446364bf5f12e5ab88c5493c35eaf04"
        ]
      },
      {
        "version": [
          3,
          10,
          0
        ],
        "commits": [
          "60ce8f0be6354ad565393ab449d8de5d713f35bc"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        6
      ],
      [
        3,
        7
      ]
    ]
  },
  {
    "id": "PSF-2021-3",
    "cve": "CVE-2021-3177",
    "published": "2021-01-19T00:00:00+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue42938",
      "issue_number": "42938"
    },
    "details": "Python 3.x through 3.9.1 has a buffer overflow in PyCArg_repr in _ctypes/callproc.c, which may lead to remote code execution in certain Python applications that accept floating-point numbers as untrusted input, as demonstrated by a 1e300 argument to c_double.from_param. This occurs because sprintf is used unsafely.",
    "affected_versions": [
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          12
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          9
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          7
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          1
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          6,
          13
        ],
        "commits": [
          "34df10a9a16b38d54421eeeaf73ec89828563be7"
        ]
      },
      {
        "version": [
          3,
          7,
          10
        ],
        "commits": [
          "d9b8f138b7df3b455b54653ca59f491b4840d6fa"
        ]
      },
      {
        "version": [
          3,
          8,
          8
        ],
        "commits": [
          "ece5dfd403dac211f8d3c72701fe7ba7b7aa5b5f"
        ]
      },
      {
        "version": [
          3,
          9,
          2
        ],
        "commits": [
          "c347cbe694743cee120457aa6626712f7799a932"
        ]
      },
      {
        "version": [
          3,
          10,
          0
        ],
        "commits": [
          "916610ef90a0d0761f08747f7b0905541f0977c7"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2021-4",
    "cve": "CVE-2021-3426",
    "published": "2021-05-20T00:00:00+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue42988",
      "issue_number": "42988"
    },
    "details": "There's a flaw in Python 3's pydoc. A local or adjacent attacker who discovers or is able to convince another local or adjacent user to start a pydoc server could access the server and use it to disclose sensitive information belonging to the other user that they would not normally be able to access. The highest risk of this flaw is to data confidentiality. This flaw affects Python versions before 3.8.9, Python versions before 3.9.3 and Python versions before 3.10.0a7.",
    "affected_versions": [
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          13
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          10
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          8
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          6,
          14
        ],
        "commits": [
          "5b1e50256b6532667b6d31debc350f6c7d3f30aa"
        ]
      },
      {
        "version": [
          3,
          7,
          11
        ],
        "commits": [
          "7c2284f97d140c4e4a85382bfb3a42440be2464d"
        ]
      },
      {
        "version": [
          3,
          8,
          9
        ],
        "commits": [
          "7e38d3309e0a5a7b9e23ef933aef0079c6e317f7"
        ]
      },
      {
        "version": [
          3,
          9,
          3
        ],
        "commits": [
          "ed753d94856213ae9fc028195f670e66a24e2334"
        ]
      },
      {
        "version": [
          3,
          10,
          0
        ],
        "commits": [
          "9b999479c0022edfc9835a8a1f06e046f3881048"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2021-5",
    "cve": null,
    "published": "2021-02-21T00:00:00+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue43285",
      "issue_number": "43285"
    },
    "details": "The IPv4 address value returned from the server in response to the PASV\ncommand should not be trusted. This prevents a malicious FTP server from\nusing the response to probe IPv4 address and port combinations on the\nclient network.\n\nInstead of using the returned address, we use the IP address we're already\nconnected to. This is the strategy other ftp clients adopted, and matches\nthe only strategy available for the modern IPv6 EPSV command where the\nserver response must return a port number and nothing else.\n",
    "affected_versions": [
      [
        [
          3,
          6,
          0
        ],
        [
          3,
          6,
          13
        ]
      ],
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          10
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          8
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          6,
          14
        ],
        "commits": [
          "4134f154ae2f621f25c5d698cc0f1748035a1b88"
        ]
      },
      {
        "version": [
          3,
          7,
          11
        ],
        "commits": [
          "79373951b3eab585d42e0f0ab83718cbe1d0ee33"
        ]
      },
      {
        "version": [
          3,
          8,
          9
        ],
        "commits": [
          "664d1d16274b47eea6ec92572e1ebf3939a6fa0c"
        ]
      },
      {
        "version": [
          3,
          9,
          3
        ],
        "commits": [
          "7dcb4baa4f0fde3aef5122a8e9f6a41853ec9335"
        ]
      },
      {
        "version": [
          3,
          10,
          0
        ],
        "commits": [
          "0ab152c6b5d95caa2dc1a30fa96e10258b5f188e"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2022-1",
    "cve": "CVE-2015-20107",
    "published": "2022-04-13T00:00:00+00:00",
    "modified": "2023-06-30T00:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue24778",
      "issue_number": "24778"
    },
    "details": "In Python (aka CPython) up to 3.10.8, the mailcap module does not add escape characters into commands discovered in the system mailcap file. This may allow attackers to inject shell commands into applications that call mailcap.findmatch with untrusted input (if they lack validation of user-provided filenames or arguments). The fix is also back-ported to 3.7, 3.8, 3.9",
    "affected_versions": [
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          13
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          13
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          12
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          4
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          7,
          16
        ],
        "commits": [
          "6e8e9e7c030b6236ff220362944cba1b93c84bc4"
        ]
      },
      {
        "version": [
          3,
          8,
          16
        ],
        "commits": [
          "0a4f650347fdcfd82d094ab2134ca89584f4e877"
        ]
      },
      {
        "version": [
          3,
          9,
          16
        ],
        "commits": [
          "c59a16e2c7495a90e6d23a48ec98623f3fb1e176"
        ]
      },
      {
        "version": [
          3,
          10,
          8
        ],
        "commits": [
          "96739bccf220689a54ef33341f431eda19c287fa"
        ]
      },
      {
        "version": [
          3,
          11,
          0
        ],
        "commits": [
          "fae93ab16377db23ba6abc10480b04a58db62bdd"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2022-2",
    "cve": "CVE-2018-1000117",
    "published": "2022-10-03T16:21:59+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue33001",
      "issue_number": "33001"
    },
    "details": "Python Software Foundation CPython version From 3.2 until 3.6.4 on Windows contains a Buffer Overflow vulnerability in os.symlink() function on Windows that can result in Arbitrary code execution, likely escalation of privilege. This attack appears to be exploitable via a python script that creates a symlink with an attacker controlled name or location. This vulnerability appears to have been fixed in 3.7.0 and 3.6.5.",
    "affected_versions": [],
    "fixed_in": [
      {
        "version": [
          3,
          4,
          9
        ],
        "commits": [
          "77c02cdce2d7b8360771be35b7676a4977e070c1"
        ]
      },
      {
        "version": [
          3,
          5,
          6
        ],
        "commits": [
          "f381cfe07d15d52f27de771a62a8167668f0dd51"
        ]
      },
      {
        "version": [
          3,
          6,
          5
        ],
        "commits": [
          "baa45079466eda1f5636a6d13f3a60c2c00fdcd3"
        ]
      },
      {
        "version": [
          3,
          7,
          0
        ],
        "commits": [
          "96fdbacb7797a564249fd59ccf86ec153c4bb095"
        ]
      },
      {
        "version": [
          3,
          8,
          0
        ],
        "commits": [
          "6921e73e33edc3c61bc2d78ed558eaa22a89a564"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2022-3",
    "cve": "CVE-2018-25032",
    "published": "2022-03-25T00:00:00+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue47194",
      "issue_number": "47194"
    },
    "details": "zlib before 1.2.12 allows memory corruption when deflating (i.e., when compressing) if the input has many distant matches.",
    "affected_versions": [
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          13
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          13
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          12
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          4
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          7,
          14
        ],
        "commits": [
          "387f93c156288c170ff0016a75af06e109d48ee1"
        ]
      },
      {
        "version": [
          3,
          8,
          14
        ],
        "commits": [
          "7ccdec3d1d837b910cd4fc5525ecde71a1326202"
        ]
      },
      {
        "version": [
          3,
          9,
          13
        ],
        "commits": [
          "0f0f85e9d8088eb789cda35477900df32adff546"
        ]
      },
      {
        "version": [
          3,
          10,
          5
        ],
        "commits": [
          "16a809ffb7af14898ce9ec8165960d96cbcd4ec3"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2022-4",
    "cve": "CVE-2020-10735",
    "published": "2022-09-09T00:00:00+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/95778",
      "issue_number": "95778"
    },
    "details": "A flaw was found in python. In algorithms with quadratic time complexity using non-binary bases, when using int(\"text\"), a system could take 50ms to parse an int string with 100,000 digits and 5s for 1,000,000 digits (float, decimal, int.from_bytes(), and int() for binary bases 2, 4, 8, 16, and 32 are not affected). The highest threat from this vulnerability is to system availability.",
    "affected_versions": [
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          13
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          13
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          13
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          6
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          7,
          14
        ],
        "commits": [
          "15ec1afd4fcd2da1e2d2b256c562fb42d8d886a2"
        ]
      },
      {
        "version": [
          3,
          8,
          14
        ],
        "commits": [
          "b5e331fdb38684808ffc540d53e8595bdc408b89"
        ]
      },
      {
        "version": [
          3,
          9,
          14
        ],
        "commits": [
          "cec1e9dfd769bd3a16142d0fdd1a36f19c77ed15"
        ]
      },
      {
        "version": [
          3,
          10,
          7
        ],
        "commits": [
          "8f0fa4bd10aba723aff988720cd26b93be99bc12"
        ]
      },
      {
        "version": [
          3,
          11,
          0
        ],
        "commits": [
          "f8b71da9aac6ea74808dcdd0cc266e705431356b"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2022-5",
    "cve": "CVE-2021-28861",
    "published": "2022-08-23T00:00:00+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/87389",
      "issue_number": "87389"
    },
    "details": "Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states \"Warning: http.server is not recommended for production. It only implements basic security checks.\"",
    "affected_versions": [
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          13
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          13
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          13
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          5
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          7,
          14
        ],
        "commits": [
          "8a34afd55258c721e446d6de4a70353c39a24148"
        ]
      },
      {
        "version": [
          3,
          8,
          14
        ],
        "commits": [
          "4dc2cae3abd75f386374d0635d00443b897d0672"
        ]
      },
      {
        "version": [
          3,
          9,
          14
        ],
        "commits": [
          "defaa2b19a9a01c79c1d5641a8aa179bb10ead3f"
        ]
      },
      {
        "version": [
          3,
          10,
          6
        ],
        "commits": [
          "5715382d3a89ca118ce2e224d8c69550d21fe51b"
        ]
      },
      {
        "version": [
          3,
          11,
          0
        ],
        "commits": [
          "e2e8847bf52f4a81490653c6d13b7e3821b2c2be"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2022-6",
    "cve": "CVE-2021-3733",
    "published": "2022-03-07T00:00:00+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue43075",
      "issue_number": "43075"
    },
    "details": "There's a flaw in urllib's AbstractBasicAuthHandler class. An attacker who controls a malicious HTTP server that an HTTP client (such as web browser) connects to, could trigger a Regular Expression Denial of Service (ReDOS) during an authentication request with a specially crafted payload that is sent by the server to the client. The greatest threat that this flaw poses is to application availability.",
    "affected_versions": [
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          10
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          9
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          4
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          6,
          14
        ],
        "commits": [
          "3fbe96123aeb66664fa547a8f6022efa2dc8788f"
        ]
      },
      {
        "version": [
          3,
          7,
          11
        ],
        "commits": [
          "ada14995870abddc277addf57dd690a2af04c2da"
        ]
      },
      {
        "version": [
          3,
          8,
          10
        ],
        "commits": [
          "e7654b6046090914a8323931ed759a94a5f85d60"
        ]
      },
      {
        "version": [
          3,
          9,
          5
        ],
        "commits": [
          "a21d4fbd549ec9685068a113660553d7f80d9b09"
        ]
      },
      {
        "version": [
          3,
          10,
          0
        ],
        "commits": [
          "7215d1ae25525c92b026166f9d5cac85fb1defe1"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2022-7",
    "cve": "CVE-2021-3737",
    "published": "2022-03-04T00:00:00+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue44022",
      "issue_number": "44022"
    },
    "details": "A flaw was found in python. An improperly handled HTTP response in the HTTP client code of python may allow a remote attacker, who controls the HTTP server, to make the client script enter an infinite loop, consuming CPU time. The highest threat from this vulnerability is to system availability.",
    "affected_versions": [
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          10
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          10
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          5
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          6,
          14
        ],
        "commits": [
          "f68d2d69f1da56c2aea1293ecf93ab69a6010ad7"
        ]
      },
      {
        "version": [
          3,
          7,
          11
        ],
        "commits": [
          "078b146f062d212919d0ba25e34e658a8234aa63"
        ]
      },
      {
        "version": [
          3,
          8,
          11
        ],
        "commits": [
          "f396864ddfe914531b5856d7bf852808ebfc01ae"
        ]
      },
      {
        "version": [
          3,
          9,
          6
        ],
        "commits": [
          "ea9327036680acc92d9f89eaf6f6a54d2f8d78d9"
        ]
      },
      {
        "version": [
          3,
          10,
          0
        ],
        "commits": [
          "60ba0b68470a584103e28958d91e93a6db37ec92"
        ]
      },
      {
        "version": [
          3,
          11,
          0
        ],
        "commits": [
          "47895e31b6f626bc6ce47d175fe9d43c1098909d"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2022-8",
    "cve": "CVE-2022-0391",
    "published": "2022-02-09T00:00:00+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue43882",
      "issue_number": "43882"
    },
    "details": "A flaw was found in Python, specifically within the urllib.parse module. This module helps break Uniform Resource Locator (URL) strings into components. The issue involves how the urlparse method does not sanitize input and allows characters like '\\r' and '\\n' in the URL path. This flaw allows an attacker to input a crafted URL, leading to injection attacks. This flaw affects Python versions prior to 3.10.0b1, 3.9.5, 3.8.11, 3.7.11 and 3.6.14.",
    "affected_versions": [
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          10
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          10
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          4
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          6,
          14
        ],
        "commits": [
          "6c472d3a1d334d4eeb4a25eba7bf3b01611bf667"
        ]
      },
      {
        "version": [
          3,
          7,
          11
        ],
        "commits": [
          "f4dac7ec55477a6c5d965e594e74bd6bda786903"
        ]
      },
      {
        "version": [
          3,
          8,
          11
        ],
        "commits": [
          "515a7bc4e13645d0945b46a8e1d9102b918cd407"
        ]
      },
      {
        "version": [
          3,
          9,
          5
        ],
        "commits": [
          "491fde0161d5e527eeff8586dd3972d7d3a631a7"
        ]
      },
      {
        "version": [
          3,
          10,
          0
        ],
        "commits": [
          "76cd81d60310d65d01f9d7b48a8985d8ab89c8b4"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2022-9",
    "cve": "CVE-2022-42919",
    "published": "2022-11-06T00:00:00+00:00",
    "modified": "2023-08-25T16:05:33+00:00",
    "severity": null,
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/97514",
      "issue_number": "97514"
    },
    "details": "Python 3.9.x before 3.9.16 and 3.10.x before 3.10.9 on Linux allows local privilege escalation in a non-default configuration. The Python multiprocessing library, when used with the forkserver start method on Linux, allows pickles to be deserialized from any user in the same machine local network namespace, which in many system configurations means any user on the same machine. Pickles can execute arbitrary code. Thus, this allows for local user privilege escalation to the user that any forkserver process is running as. Setting multiprocessing.util.abstract_sockets_supported to False is a workaround. The forkserver start method for multiprocessing is not the default start method. This issue is Linux specific because only Linux supports abstract namespace sockets. CPython before 3.9 does not make use of Linux abstract namespace sockets by default. Support for users manually specifying an abstract namespace socket was added as a bugfix in 3.7.8 and 3.8.3, but users would need to make specific uncommon API calls in order to do that in CPython before 3.9.",
    "affected_versions": [
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          15
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          15
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          15
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          8
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          9,
          16
        ],
        "commits": [
          "b43496c01a554cf41ae654a0379efae18609ad39"
        ]
      },
      {
        "version": [
          3,
          10,
          9
        ],
        "commits": [
          "eae692eed18892309bcc25a2c0f8980038305ea2"
        ]
      },
      {
        "version": [
          3,
          11,
          0
        ],
        "commits": [
          "4c0c1e201a896ee5141df9a698e8a94aad2d5e6d"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        7
      ],
      [
        3,
        8
      ]
    ]
  },
  {
    "id": "PSF-2022-10",
    "cve": "CVE-2022-45061",
    "published": "2022-11-09T00:00:00+00:00",
    "modified": "2023-06-30T00:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/98433",
      "issue_number": "98433"
    },
    "details": "An issue was discovered in Python before 3.11.1. An unnecessary quadratic algorithm exists in one path when processing some inputs to the IDNA (RFC 3490) decoder, such that a crafted, unreasonably long name being presented to the decoder could lead to a CPU denial of service. Hostnames are often supplied by remote servers that could be controlled by a malicious actor; in such a scenario, they could trigger excessive CPU consumption on the client attempting to make use of an attacker-supplied supposed hostname. For example, the attack payload could be placed in the Location header of an HTTP response with status code 302. A fix is planned in 3.11.1, 3.10.9, 3.9.16, 3.8.16, and 3.7.16.",
    "affected_versions": [
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          15
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          15
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          15
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          8
        ]
      ],
      [
        [
          3,
          11,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          7,
          16
        ],
        "commits": [
          "b0b590be9597fd5919228d251812dd54145f70a7"
        ]
      },
      {
        "version": [
          3,
          8,
          16
        ],
        "commits": [
          "82ca2839c9ec6bf9a9400e791a52411824df67f3"
        ]
      },
      {
        "version": [
          3,
          9,
          16
        ],
        "commits": [
          "c09dba57cfbbf74273ce44b1f48f71b46806605c"
        ]
      },
      {
        "version": [
          3,
          10,
          9
        ],
        "commits": [
          "9bb8e18ca46fe66fa6802602f8a7228a24dd785f"
        ]
      },
      {
        "version": [
          3,
          11,
          1
        ],
        "commits": [
          "a6f6c3a3d6f2b580f2d87885c9b8a9350ad7bf15"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2022-11",
    "cve": "CVE-2022-37454",
    "published": "2022-10-21T00:00:00+00:00",
    "modified": "2023-03-07T03:42:54+00:00",
    "severity": null,
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/98517",
      "issue_number": "98517"
    },
    "details": "The Keccak XKCP SHA-3 reference implementation before fdc6fef has an integer overflow and resultant buffer overflow that allows attackers to execute arbitrary code or eliminate expected cryptographic properties. This occurs in the sponge function interface.",
    "affected_versions": [
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          15
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          15
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          15
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          8
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          7,
          16
        ],
        "commits": [
          "8088c90044ba04cd5624b278340ebf934dbee4a5"
        ]
      },
      {
        "version": [
          3,
          8,
          16
        ],
        "commits": [
          "948c6794711458fd148a3fa62296cadeeb2ed631"
        ]
      },
      {
        "version": [
          3,
          9,
          16
        ],
        "commits": [
          "857efee6d2d43c5c12fc7e377ce437144c728ab8"
        ]
      },
      {
        "version": [
          3,
          10,
          9
        ],
        "commits": [
          "0e4e058602d93b88256ff90bbef501ba20be9dd3"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2023-1",
    "cve": "CVE-2023-24329",
    "published": "2023-02-17T00:00:00+00:00",
    "modified": "2023-08-11T00:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/99418",
      "issue_number": "99418"
    },
    "details": "An issue in the urllib.parse component of Python before 3.11.4 allows attackers to bypass blocklisting methods by supplying a URL that starts with blank characters.",
    "affected_versions": [
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          16
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          16
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          16
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          10
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          9,
          17
        ],
        "commits": [
          "d7f8a5fe07b0ff3a419ccec434cc405b21a5a304"
        ]
      },
      {
        "version": [
          3,
          10,
          12
        ],
        "commits": [
          "f48a96a28012d28ae37a2f4587a780a5eb779946"
        ]
      },
      {
        "version": [
          3,
          11,
          4
        ],
        "commits": [
          "610cc0ab1b760b2abaac92bd256b96191c46b941"
        ]
      },
      {
        "version": [
          3,
          12,
          0
        ],
        "commits": [
          "2f630e1ce18ad2e07428296532a68b11dc66ad10"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        7
      ],
      [
        3,
        8
      ]
    ]
  },
  {
    "id": "PSF-2023-2",
    "cve": "CVE-2023-27043",
    "published": "2023-04-18T00:00:00+00:00",
    "modified": "2023-06-01T00:00:00+00:00",
    "severity": null,
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/102988",
      "issue_number": "102988"
    },
    "details": "The email module of Python through 3.11.3 incorrectly parses e-mail addresses that contain a special character. The wrong portion of an RFC2822 header is identified as the value of the addr-spec. In some applications, an attacker can bypass a protection mechanism in which application access is granted only after verifying receipt of e-mail to a specific domain (e.g., only @company.example.com addresses may be used for signup). This occurs in email/_parseaddr.py in recent versions of Python.",
    "affected_versions": [
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          16
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          16
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          16
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          11
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          13,
          0
        ],
        "commits": [
          "4a153a1d3b18803a684cd1bcc2cdf3ede3dbae19"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        7
      ],
      [
        3,
        8
      ],
      [
        3,
        9
      ],
      [
        3,
        10
      ],
      [
        3,
        11
      ]
    ]
  },
  {
    "id": "PSF-2023-3",
    "cve": "CVE-2023-33595",
    "published": "2023-06-07T00:00:00+00:00",
    "modified": "2023-08-28T16:57:11+00:00",
    "severity": null,
    "issue": null,
    "details": "CPython v3.12.0 alpha 7 was discovered to contain a heap use-after-free via the function ascii_decode at /Objects/unicodeobject.c.",
    "affected_versions": [],
    "fixed_in": [
      {
        "version": [
          3,
          12,
          0
        ],
        "commits": [
          "d5a97074d24cd14cb2a35a2b1ad3074863cde264"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2023-4",
    "cve": "CVE-2023-36632",
    "published": "2023-06-25T00:00:00+00:00",
    "modified": "2023-08-28T16:57:11+00:00",
    "severity": null,
    "issue": null,
    "details": "The legacy email.utils.parseaddr function in Python through 3.11.4 allows attackers to trigger \"RecursionError: maximum recursion depth exceeded while calling a Python object\" via a crafted argument. This argument is plausibly an untrusted value from an application's input data that was supposed to contain a name and an e-mail address. NOTE: email.utils.parseaddr is categorized as a Legacy API in the documentation of the Python email package. Applications should instead use the email.parser.BytesParser or email.parser.Parser class. NOTE: the vendor's perspective is that this is neither a vulnerability nor a bug. The email package is intended to have size limits and to throw an exception when limits are exceeded; they were exceeded by the example demonstration code.",
    "affected_versions": [
      [
        [
          3,
          7,
          0
        ],
        [
          3,
          7,
          17
        ]
      ],
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          17
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          17
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          12
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          4
        ]
      ]
    ],
    "fixed_in": [],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        7
      ],
      [
        3,
        8
      ],
      [
        3,
        9
      ],
      [
        3,
        10
      ],
      [
        3,
        11
      ]
    ]
  },
  {
    "id": "PSF-2023-5",
    "cve": "CVE-2022-48565",
    "published": "2023-08-24T00:00:00+00:00",
    "modified": "2023-08-28T16:57:11+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue42051",
      "issue_number": "42051"
    },
    "details": "An XML External Entity (XXE) issue was discovered in Python through 3.9.1. The plistlib module no longer accepts entity declarations in XML plist files to avoid XML vulnerabilities.",
    "affected_versions": [
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          6
        ]
      ],
      [
        [
          3,
          9,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          6,
          13
        ],
        "commits": [
          "a158fb9c5138db94adf24fbc5690467cda811163"
        ]
      },
      {
        "version": [
          3,
          7,
          10
        ],
        "commits": [
          "e512bc799e3864fe3b1351757261762d63471efc"
        ]
      },
      {
        "version": [
          3,
          8,
          7
        ],
        "commits": [
          "65894cac0835cb8f469f649e20aa1be8bf89f5ae"
        ]
      },
      {
        "version": [
          3,
          9,
          1
        ],
        "commits": [
          "479553c7c11306a09ce34edb6ef208133b7b95fe"
        ]
      },
      {
        "version": [
          3,
          10,
          0
        ],
        "commits": [
          "05ee790f4d1cd8725a90b54268fc1dfe5b4d1fa2"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2023-6",
    "cve": "CVE-2022-48566",
    "published": "2023-08-24T00:00:00+00:00",
    "modified": "2023-08-28T16:57:11+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue40791",
      "issue_number": "40791"
    },
    "details": "An issue was discovered in compare_digest in Lib/hmac.py in Python through 3.9.1. Constant-time-defeating optimisations were possible in the accumulator variable in hmac.compare_digest.",
    "affected_versions": [
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          6
        ]
      ],
      [
        [
          3,
          9,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          6,
          13
        ],
        "commits": [
          "8bef9ebb1b88cfa4b2a38b93fe4ea22015d8254a"
        ]
      },
      {
        "version": [
          3,
          7,
          10
        ],
        "commits": [
          "db95802bdfac4d13db3e2a391ec7b9e2f8d92dbe"
        ]
      },
      {
        "version": [
          3,
          8,
          7
        ],
        "commits": [
          "97136d71a78a4b6b816f7e14acc52be426efcb6f"
        ]
      },
      {
        "version": [
          3,
          9,
          1
        ],
        "commits": [
          "c1bbca5b004b3f74d240ef8a76ff445cc1a27efb"
        ]
      },
      {
        "version": [
          3,
          10,
          0
        ],
        "commits": [
          "31729366e2bc09632e78f3896dbce0ae64914f28"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2023-7",
    "cve": "CVE-2023-38898",
    "published": "2023-08-15T00:00:00+00:00",
    "modified": "2023-08-28T16:57:11+00:00",
    "severity": null,
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/105987",
      "issue_number": "105987"
    },
    "details": "An issue in Python CPython 3.12.0b1 allows an attacker to obtain sensitive information via the _asyncio._swap_current_task() component.",
    "affected_versions": [],
    "fixed_in": [
      {
        "version": [
          3,
          12,
          0
        ],
        "commits": [
          "9e6f8d46150c1a0af09d68ce63c603cf321994aa"
        ]
      },
      {
        "version": [
          3,
          13,
          0
        ],
        "commits": [
          "d2cbb6e918d9ea39f0dd44acb53270f2dac07454"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2023-8",
    "cve": "CVE-2023-40217",
    "published": "2023-08-24T00:00:00+00:00",
    "modified": "2023-08-28T16:57:11+00:00",
    "severity": null,
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/108310",
      "issue_number": "108310"
    },
    "details": "Instances of `ssl.SSLSocket` are vulnerable to a bypass of the TLS handshake and included protections (like certificate verification) and treating sent unencrypted data as if it were post-handshake TLS encrypted data.\n\nThe vulnerability is caused when a socket is connected, data is sent by the malicious peer and stored in a buffer, and then the malicious peer closes the socket within a small timing window before the other peers\u2019 TLS handshake can begin. After this sequence of events the closed socket will not immediately attempt a TLS handshake due to not being connected but will also allow the buffered data to be read as if a successful TLS handshake had occurred.\n\n### Affected usages\n\nThis vulnerability **primarily affects** HTTPS servers and other server-side protocols using TLS client authentication due to requiring reading data immediately after the handshake to be vulnerable. Operations which would fail on a closed socket (like sending data) immediately after the handshake **are not affected by this vulnerability.**\n\nBecause disconnecting the socket is a necessary step to trigger the vulnerability **there is no risk of data exfiltration or data leakage directly from the malicious TLS connection**, however the vulnerability does carry risk for modifying or deleting resources which are authenticated using only TLS client certificates.\n\nThis vulnerability **affects** clients who are reading and processing data from the server after a TLS handshake without sending any data first. Our team is unaware of a protocol that uses TLS that fits this usage pattern.\n\nThis vulnerability **does not affect** client-side HTTPS connections like pip or requests as an HTTP request must be sent before an HTTP response is read meaning the connection would already be closed by the time the client is sending an HTTP request, leading to an error.\n\nThis vulnerability **affects, but has no impact** on servers that aren\u2019t using TLS client certificate authentication as traffic to a non-authenticating TLS server loses nothing from a bypassed handshake to inject a query and close the connection as the same action could be taken by a peer using a TLS connection with a proper handshake.",
    "affected_versions": [
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          17
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          17
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          12
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          4
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          8,
          18
        ],
        "commits": [
          "b4bcc06a9cfe13d96d5270809d963f8ba278f89b"
        ]
      },
      {
        "version": [
          3,
          9,
          18
        ],
        "commits": [
          "264b1dacc67346efa0933d1e63f622676e0ed96b"
        ]
      },
      {
        "version": [
          3,
          10,
          13
        ],
        "commits": [
          "37d7180cb647f0bed0c1caab0037f3bc82e2af96"
        ]
      },
      {
        "version": [
          3,
          11,
          5
        ],
        "commits": [
          "75a875e0df0530b75b1470d797942f90f4a718d3"
        ]
      },
      {
        "version": [
          3,
          12,
          0
        ],
        "commits": [
          "256586ab8776e4526ca594b4866b9a3492e628f1"
        ]
      },
      {
        "version": [
          3,
          13,
          0
        ],
        "commits": [
          "0cb0c238d520a8718e313b52cffc356a5a7561bf"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2023-9",
    "cve": "CVE-2023-41105",
    "published": "2023-08-24T00:00:00+00:00",
    "modified": "2023-08-31T19:09:53+00:00",
    "severity": null,
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/106242",
      "issue_number": "106242"
    },
    "details": "Passing a path with null bytes to the `os.path.normpath()` function causes the returned path to be unexpectedly truncated at the first occurrence of null bytes within the path. Python versions before 3.11.0 didn\u2019t truncate the path on null bytes.\n\nIf allowlisting is applied before a call to `os.path.normpath()` is used later in the program, the allowlisting can be circumvented if the path containing null bytes is constructed to pass the allowlist but then change to the targeted resource after truncation.",
    "affected_versions": [
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          4
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          11,
          5
        ],
        "commits": [
          "ccf81e1088c25a9f4464e478dc3b5c03ed7ee63b"
        ]
      },
      {
        "version": [
          3,
          12,
          0
        ],
        "commits": [
          "ede98958810b76694cf756d305b564cd6adc1a48"
        ]
      },
      {
        "version": [
          3,
          13,
          0
        ],
        "commits": [
          "09322724319d4c23195300b222a1c0ea720af56b"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2023-10",
    "cve": "CVE-2022-48564",
    "published": "2023-08-22T00:00:00+00:00",
    "modified": "2023-08-28T16:57:11+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue42103",
      "issue_number": "42103"
    },
    "details": "read_ints in plistlib.py in Python through 3.9.1 is vulnerable to a potential DoS attack via CPU and RAM exhaustion when processing malformed Apple Property List files in binary format.",
    "affected_versions": [
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          6
        ]
      ],
      [
        [
          3,
          9,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          7,
          10
        ],
        "commits": [
          "225e3659556616ad70186e7efc02baeebfeb5ec4"
        ]
      },
      {
        "version": [
          3,
          8,
          7
        ],
        "commits": [
          "547d2bcc55e348043b2f338027c1acd9549ada76"
        ]
      },
      {
        "version": [
          3,
          9,
          1
        ],
        "commits": [
          "e277cb76989958fdbc092bf0b2cb55c43e86610a"
        ]
      },
      {
        "version": [
          3,
          10,
          0
        ],
        "commits": [
          "34637a0ce21e7261b952fbd9d006474cc29b681f"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2023-11",
    "cve": "CVE-2022-48560",
    "published": "2023-08-22T00:00:00+00:00",
    "modified": "2023-08-28T16:57:11+00:00",
    "severity": null,
    "issue": {
      "type": "bpo",
      "url": "https://bugs.python.org/issue39421",
      "issue_number": "39421"
    },
    "details": "A use-after-free exists in Python through 3.9 via heappushpop in heapq.",
    "affected_versions": [
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          1
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          6,
          11
        ],
        "commits": [
          "c563f409ea30bcb0623d785428c9257917371b76"
        ]
      },
      {
        "version": [
          3,
          7,
          7
        ],
        "commits": [
          "958064f8d2b84062b0582bbae911df8ccfc11fd6"
        ]
      },
      {
        "version": [
          3,
          8,
          2
        ],
        "commits": [
          "993811ffe75c2573f97fb3fd1414b34609b8c8db"
        ]
      },
      {
        "version": [
          3,
          9,
          0
        ],
        "commits": [
          "79f89e6e5a659846d1068e8b1bd8e491ccdef861"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2023-12",
    "cve": "CVE-2023-6507",
    "published": "2023-12-08T18:20:49.583000+00:00",
    "modified": "2024-06-04T17:17:02.629000+00:00",
    "severity": {
      "name": "MEDIUM",
      "score": 6.1,
      "version": "3.1"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/112334",
      "issue_number": "112334"
    },
    "details": "An issue was found in CPython 3.12.0 `subprocess` module on POSIX platforms. The issue was fixed in CPython 3.12.1 and does not affect other stable releases.\n\nWhen using the `extra_groups=` parameter with an empty list as a value (ie `extra_groups=[]`) the logic regressed to not call `setgroups(0, NULL)` before calling `exec()`, thus not dropping the original processes' groups before starting the new process. There is no issue when the parameter isn't used or when any value is used besides an empty list.\n\nThis issue only impacts CPython processes run with sufficient privilege to make the `setgroups` system call (typically `root`).\n\n",
    "affected_versions": [
      [
        [
          3,
          12,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          12,
          1
        ],
        "commits": [
          "85bbfa8a4bbdbb61a3a84fbd7cb29a4096ab8a06"
        ]
      },
      {
        "version": [
          3,
          13,
          0
        ],
        "commits": [
          "10e9bb13b8dcaa414645b9bd10718d8f7179e82b",
          "9fe7655c6ce0b8e9adc229daf681b6d30e6b1610"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2024-1",
    "cve": "CVE-2023-6597",
    "published": "2024-03-19T15:44:28.989000+00:00",
    "modified": "2024-06-13T19:24:11.289000+00:00",
    "severity": {
      "name": "HIGH",
      "score": 7.8,
      "version": "3.1"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/91133",
      "issue_number": "91133"
    },
    "details": "An issue was found in the CPython `tempfile.TemporaryDirectory` class affecting versions 3.12.1, 3.11.7, 3.10.13, 3.9.18, and 3.8.18 and prior.\n\nThe tempfile.TemporaryDirectory class would dereference symlinks during cleanup of permissions-related errors. This means users which can run privileged programs are potentially able to modify permissions of files referenced by symlinks in some circumstances.\n",
    "affected_versions": [
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          18
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          18
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          13
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          7
        ]
      ],
      [
        [
          3,
          12,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          8,
          19
        ],
        "commits": [
          "02a9259c717738dfe6b463c44d7e17f2b6d2cb3a"
        ]
      },
      {
        "version": [
          3,
          9,
          19
        ],
        "commits": [
          "d54e22a669ae6e987199bb5d2c69bb5a46b0083b"
        ]
      },
      {
        "version": [
          3,
          10,
          14
        ],
        "commits": [
          "8eaeefe49d179ca4908d052745e3bb8b6f238f82"
        ]
      },
      {
        "version": [
          3,
          11,
          8
        ],
        "commits": [
          "5585334d772b253a01a6730e8202ffb1607c3d25"
        ]
      },
      {
        "version": [
          3,
          12,
          1
        ],
        "commits": [
          "6ceb8aeda504b079fef7a57b8d81472f15cdd9a5"
        ]
      },
      {
        "version": [
          3,
          13,
          0
        ],
        "commits": [
          "81c16cd94ec38d61aa478b9a452436dc3b1b524d"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2024-2",
    "cve": "CVE-2024-0450",
    "published": "2024-03-19T15:12:07.789000+00:00",
    "modified": "2024-06-13T19:24:15.993000+00:00",
    "severity": {
      "name": "MEDIUM",
      "score": 6.2,
      "version": "3.1"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/109858",
      "issue_number": "109858"
    },
    "details": "An issue was found in the CPython `zipfile` module affecting versions 3.12.1, 3.11.7, 3.10.13, 3.9.18, and 3.8.18 and prior.\n\nThe zipfile module is vulnerable to \u201cquoted-overlap\u201d zip-bombs which exploit the zip format to create a zip-bomb with a high compression ratio. The fixed versions of CPython makes the zipfile module reject zip archives which overlap entries in the archive.\n\n",
    "affected_versions": [
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          18
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          18
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          13
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          7
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          1
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          8,
          19
        ],
        "commits": [
          "d05bac0b74153beb541b88b4fca33bf053990183"
        ]
      },
      {
        "version": [
          3,
          9,
          19
        ],
        "commits": [
          "a2c59992e9e8d35baba9695eb186ad6c6ff85c51"
        ]
      },
      {
        "version": [
          3,
          10,
          14
        ],
        "commits": [
          "30fe5d853b56138dbec62432d370a1f99409fc85"
        ]
      },
      {
        "version": [
          3,
          11,
          8
        ],
        "commits": [
          "a956e510f6336d5ae111ba429a61c3ade30a7549"
        ]
      },
      {
        "version": [
          3,
          12,
          2
        ],
        "commits": [
          "fa181fcf2156f703347b03a3b1966ce47be8ab3b"
        ]
      },
      {
        "version": [
          3,
          13,
          0
        ],
        "commits": [
          "66363b9a7b9fe7c99eba3a185b74c5fdbf842eba",
          "70497218351ba44bffc8b571201ecb5652d84675"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2024-3",
    "cve": "CVE-2024-4030",
    "published": "2024-05-07T21:02:55.284000+00:00",
    "modified": "2024-09-07T02:44:36.613000+00:00",
    "severity": null,
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/118486",
      "issue_number": "118486"
    },
    "details": "On Windows a directory returned by tempfile.mkdtemp() would not always have permissions set to restrict reading and writing to the temporary directory by other users, instead usually inheriting the correct permissions from the default location. Alternate configurations or users without a profile directory may not have the intended permissions.\n\nIf you\u2019re not using Windows or haven\u2019t changed the temporary directory location then you aren\u2019t affected by this vulnerability. On other platforms the returned directory is consistently readable and writable only by the current user.\n\nThis issue was caused by Python not supporting Unix permissions on Windows. The fix adds support for Unix \u201c700\u201d for the mkdir function on Windows which is used by mkdtemp() to ensure the newly created directory has the proper permissions.",
    "affected_versions": [
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          19
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          19
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          14
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          9
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          8,
          20
        ],
        "commits": [
          "91e3669e01245185569d09e9e6e11641282971ee"
        ]
      },
      {
        "version": [
          3,
          9,
          20
        ],
        "commits": [
          "5130731c9e779b97d00a24f54cdce73ce9975dfd"
        ]
      },
      {
        "version": [
          3,
          10,
          15
        ],
        "commits": [
          "c8f868dc52f98011d0f9b459b6487920bfb0ac4d"
        ]
      },
      {
        "version": [
          3,
          11,
          10
        ],
        "commits": [
          "35c799d79177b962ddace2fa068101465570a29a"
        ]
      },
      {
        "version": [
          3,
          12,
          4
        ],
        "commits": [
          "6d0850c4c8188035643586ab4d8ec2468abd699e",
          "eb29e2f5905da93333d1ce78bc98b151e763ff46"
        ]
      },
      {
        "version": [
          3,
          13,
          0
        ],
        "commits": [
          "81939dad77001556c527485d31a2d0f4a759033e",
          "8ed546679524140d8282175411fd141fe7df070d",
          "d86b49411753bf2c83291e3a14ae43fefded2f84",
          "e1dfa978b1ad210d551385ad8073ec6154f53763"
        ]
      },
      {
        "version": [
          3,
          14,
          0
        ],
        "commits": [
          "66f8bb76a15e64a1bb7688b177ed29e26230fdee",
          "94591dca510c796c7d40e9b4167ea56f2fdf28ca"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2024-4",
    "cve": "CVE-2024-0397",
    "published": "2024-06-17T15:09:40.896000+00:00",
    "modified": "2024-06-17T15:11:16.322000+00:00",
    "severity": null,
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/114572",
      "issue_number": "114572"
    },
    "details": "A defect was discovered in the Python \u201cssl\u201d module where there is a memory\nrace condition with the ssl.SSLContext methods \u201ccert_store_stats()\u201d and\n\u201cget_ca_certs()\u201d. The race condition can be triggered if the methods are\ncalled at the same time as certificates are loaded into the SSLContext,\nsuch as during the TLS handshake with a certificate directory configured.\nThis issue is fixed in CPython 3.10.14, 3.11.9, 3.12.3, and 3.13.0a5.",
    "affected_versions": [
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          19
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          19
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          13
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          8
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          8,
          20
        ],
        "commits": [
          "29c97287d205bf2f410f4895ebce3f43b5160524"
        ]
      },
      {
        "version": [
          3,
          9,
          20
        ],
        "commits": [
          "b228655c227b2ca298a8ffac44d14ce3d22f6faa"
        ]
      },
      {
        "version": [
          3,
          10,
          14
        ],
        "commits": [
          "37324b421b72b7bc9934e27aba85d48d4773002e"
        ]
      },
      {
        "version": [
          3,
          11,
          9
        ],
        "commits": [
          "01c37f1d0714f5822d34063ca7180b595abf589d"
        ]
      },
      {
        "version": [
          3,
          12,
          3
        ],
        "commits": [
          "542f3272f56f31ed04e74c40635a913fbc12d286"
        ]
      },
      {
        "version": [
          3,
          13,
          0
        ],
        "commits": [
          "bce693111bff906ccf9281c22371331aaff766ab"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2024-5",
    "cve": "CVE-2024-4032",
    "published": "2024-06-17T15:05:58.827000+00:00",
    "modified": "2024-06-17T15:11:36.402000+00:00",
    "severity": null,
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/113171",
      "issue_number": "113171"
    },
    "details": "The \u201cipaddress\u201d module contained incorrect information about whether certain IPv4 and IPv6 addresses were designated as \u201cglobally reachable\u201d or \u201cprivate\u201d. This affected the is_private and is_global properties of the ipaddress.IPv4Address, ipaddress.IPv4Network, ipaddress.IPv6Address, and ipaddress.IPv6Network classes, where values wouldn\u2019t be returned in accordance with the latest information from the IANA Special-Purpose Address Registries.\n\nCPython 3.12.4 and 3.13.0a6 contain updated information from these registries and thus have the intended behavior.",
    "affected_versions": [
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          19
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          19
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          14
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          9
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          8,
          20
        ],
        "commits": [
          "895f7e2ac23eff4743143beef0f0c5ac71ea27d3"
        ]
      },
      {
        "version": [
          3,
          9,
          20
        ],
        "commits": [
          "22adf29da8d99933ffed8647d3e0726edd16f7f8"
        ]
      },
      {
        "version": [
          3,
          10,
          15
        ],
        "commits": [
          "c62c9e518b784fe44432a3f4fc265fb95b651906"
        ]
      },
      {
        "version": [
          3,
          11,
          10
        ],
        "commits": [
          "ba431579efdcbaed7a96f2ac4ea0775879a332fb"
        ]
      },
      {
        "version": [
          3,
          12,
          4
        ],
        "commits": [
          "f86b17ac511e68192ba71f27e752321a3252cee3"
        ]
      },
      {
        "version": [
          3,
          13,
          0
        ],
        "commits": [
          "40d75c2b7f5c67e254d0a025e0f2e2c7ada7f69f"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2024-6",
    "cve": "CVE-2024-5642",
    "published": "2024-06-27T21:05:31.281000+00:00",
    "modified": "2025-10-07T16:17:14.739000+00:00",
    "severity": null,
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/121227",
      "issue_number": "121227"
    },
    "details": "CPython 3.9 and earlier doesn't disallow configuring an empty list (\"[]\") for SSLContext.set_npn_protocols() which is an invalid value for the underlying OpenSSL API. This results in a buffer over-read when NPN is used (see CVE-2024-5535 for OpenSSL). This vulnerability is of low severity due to NPN being not widely used and specifying an empty list likely being uncommon in-practice (typically a protocol name would be configured).",
    "affected_versions": [
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          20
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          23
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          9,
          24
        ],
        "commits": [
          "a2cdbb6e8188ba9ba8b356b28d91bff60e86fe31"
        ]
      },
      {
        "version": [
          3,
          10,
          0
        ],
        "commits": [
          "39258d3595300bc7b952854c915f63ae2d4b9c3e"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        8
      ]
    ]
  },
  {
    "id": "PSF-2024-7",
    "cve": "CVE-2024-3219",
    "published": "2024-07-29T21:54:05.830000+00:00",
    "modified": "2025-01-31T19:54:41.350000+00:00",
    "severity": {
      "name": "MEDIUM",
      "score": 5.1,
      "version": "4.0"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/122133",
      "issue_number": "122133"
    },
    "details": "The\n \u201csocket\u201d module provides a pure-Python fallback to the \nsocket.socketpair() function for platforms that don\u2019t support AF_UNIX, \nsuch as Windows. This pure-Python implementation uses AF_INET or \nAF_INET6 to create a local connected pair of sockets. The connection \nbetween the two sockets was not verified before passing the two sockets \nback to the user, which leaves the server socket vulnerable to a \nconnection race from a malicious local peer.\n\nPlatforms that support AF_UNIX such as Linux and macOS are not affected by this vulnerability. Versions prior to CPython 3.5 are not affected due to the vulnerable API not being included.",
    "affected_versions": [
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          19
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          19
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          14
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          9
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          4
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          8,
          20
        ],
        "commits": [
          "2621a8a40ba4b2c68ca564671b7daa5da80a4508",
          "e319f774f9e766a2b92949444a2d46081df3363a"
        ]
      },
      {
        "version": [
          3,
          9,
          20
        ],
        "commits": [
          "06fa244666ec6335a3b9bf2367e31b42b9a89b20",
          "3f5d9d12c74787fbf3f5891835c85cc15526c86d"
        ]
      },
      {
        "version": [
          3,
          10,
          15
        ],
        "commits": [
          "0b65c8bf5367625673eafb92f85046a1b31259f2",
          "31302f5fc24eecd693f0c8aaba7c2840b09b594d"
        ]
      },
      {
        "version": [
          3,
          11,
          10
        ],
        "commits": [
          "5f90abaa786f994db3907fc31e2ee00ea2cf0929",
          "c5655aa6ad120d2ed7f255bebd6e8b71a9c07dde"
        ]
      },
      {
        "version": [
          3,
          12,
          5
        ],
        "commits": [
          "220e31adeaaa8436c9ff234cba1398bc49e2bb6c",
          "5df322e91a40909e6904bbdbc0c3a6b6a9eead39"
        ]
      },
      {
        "version": [
          3,
          13,
          0
        ],
        "commits": [
          "b252317956b7fc035bb3774ef6a177e227f9fc54",
          "c21a36112a0028d7ac3cf8f480e0dc88dba5922c"
        ]
      },
      {
        "version": [
          3,
          14,
          0
        ],
        "commits": [
          "78df1043dbdce5c989600616f9f87b4ee72944e5",
          "f071f01b7b7e19d7d6b3a4b0ec62f820ecb14660"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2024-8",
    "cve": "CVE-2024-6923",
    "published": "2024-08-01T13:40:11.069000+00:00",
    "modified": "2025-01-31T19:55:06.174000+00:00",
    "severity": null,
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/121650",
      "issue_number": "121650"
    },
    "details": "There is a MEDIUM severity vulnerability affecting CPython.\n\nThe \nemail module didn\u2019t properly quote newlines for email headers when \nserializing an email message allowing for header injection when an email\n is serialized.",
    "affected_versions": [
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          19
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          19
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          14
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          9
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          4
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          8,
          20
        ],
        "commits": [
          "b158a76ce094897c870fb6b3de62887b7ccc33f1"
        ]
      },
      {
        "version": [
          3,
          9,
          20
        ],
        "commits": [
          "f7be505d137a22528cb0fc004422c0081d5d90e6"
        ]
      },
      {
        "version": [
          3,
          10,
          15
        ],
        "commits": [
          "06f28dc236708f72871c64d4bc4b4ea144c50147"
        ]
      },
      {
        "version": [
          3,
          11,
          10
        ],
        "commits": [
          "f7c0f09e69e950cf3c5ada9dbde93898eb975533"
        ]
      },
      {
        "version": [
          3,
          12,
          5
        ],
        "commits": [
          "4766d1200fdf8b6728137aa2927a297e224d5fa7"
        ]
      },
      {
        "version": [
          3,
          13,
          0
        ],
        "commits": [
          "4aaa4259b5a6e664b7316a4d60bdec7ee0f124d0"
        ]
      },
      {
        "version": [
          3,
          14,
          0
        ],
        "commits": [
          "097633981879b3c9de9a1dd120d3aa585ecc2384"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2024-9",
    "cve": "CVE-2024-7592",
    "published": "2024-08-19T19:06:45.311000+00:00",
    "modified": "2025-01-31T19:55:12.119000+00:00",
    "severity": null,
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/123067",
      "issue_number": "123067"
    },
    "details": "There is a LOW severity vulnerability affecting CPython, specifically the\n'http.cookies' standard library module.\n\n\nWhen parsing cookies that contained backslashes for quoted characters in\nthe cookie value, the parser would use an algorithm with quadratic\ncomplexity, resulting in excess CPU resources being used while parsing the\nvalue.",
    "affected_versions": [
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          19
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          19
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          14
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          9
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          5
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          8,
          20
        ],
        "commits": [
          "a77ab24427a18bff817025adb03ca920dc3f1a06"
        ]
      },
      {
        "version": [
          3,
          9,
          20
        ],
        "commits": [
          "d662e2db2605515a767f88ad48096b8ac623c774"
        ]
      },
      {
        "version": [
          3,
          10,
          15
        ],
        "commits": [
          "b2f11ca7667e4d57c71c1c88b255115f16042d9a"
        ]
      },
      {
        "version": [
          3,
          11,
          10
        ],
        "commits": [
          "d4ac921a4b081f7f996a5d2b101684b67ba0ed7f"
        ]
      },
      {
        "version": [
          3,
          12,
          6
        ],
        "commits": [
          "dcc3eaef98cd94d6cb6cb0f44bd1c903d04f33b1"
        ]
      },
      {
        "version": [
          3,
          13,
          0
        ],
        "commits": [
          "391e5626e3ee5af267b97e37abc7475732e67621"
        ]
      },
      {
        "version": [
          3,
          14,
          0
        ],
        "commits": [
          "44e458357fca05ca0ae2658d62c8c595b048b5ef"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2024-10",
    "cve": "CVE-2024-8088",
    "published": "2024-08-22T18:45:31.807000+00:00",
    "modified": "2025-10-07T18:23:00.951000+00:00",
    "severity": {
      "name": "HIGH",
      "score": 8.7,
      "version": "4.0"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/122905",
      "issue_number": "122905"
    },
    "details": "There is a HIGH severity vulnerability affecting the CPython \"zipfile\"\nmodule affecting \"zipfile.Path\". Note that the more common API \"zipfile.ZipFile\" class is unaffected.\n\n\n\n\n\nWhen iterating over names of entries in a zip archive (for example, methods\nof \"zipfile.Path\" like \"namelist()\", \"iterdir()\", etc)\nthe process can be put into an infinite loop with a maliciously crafted\nzip archive. This defect applies when reading only metadata or extracting\nthe contents of the zip archive. Programs that are not handling\nuser-controlled zip archives are not affected.",
    "affected_versions": [
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          19
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          19
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          14
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          9
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          5
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          8,
          20
        ],
        "commits": [
          "7bc367e464ce50b956dd232c1dfa1cad4e7fb814"
        ]
      },
      {
        "version": [
          3,
          9,
          20
        ],
        "commits": [
          "962055268ed4f2ca1d717bfc8b6385de50a23ab7"
        ]
      },
      {
        "version": [
          3,
          10,
          15
        ],
        "commits": [
          "0aa1ee22ab6e204e9d3d0e9dd63ea648ed691ef1",
          "e0264a61119d551658d9445af38323ba94fc16db"
        ]
      },
      {
        "version": [
          3,
          11,
          10
        ],
        "commits": [
          "795f2597a4be988e2bb19b69ff9958e981cb894e",
          "fc0b8259e693caa8400fa8b6ac1e494e47ea7798"
        ]
      },
      {
        "version": [
          3,
          12,
          6
        ],
        "commits": [
          "95b073bddefa6243effa08e131e297c0383e7f6a",
          "dcc5182f27c1500006a1ef78e10613bb45788dea"
        ]
      },
      {
        "version": [
          3,
          13,
          0
        ],
        "commits": [
          "7e8883a3f04d308302361aeffc73e0e9837f19d4",
          "8c7348939d8a3ecd79d630075f6be1b0c5b41f64"
        ]
      },
      {
        "version": [
          3,
          14,
          0
        ],
        "commits": [
          "2231286d78d328c2f575e0b05b16fe447d1656d6",
          "9cd03263100ddb1657826cc4a71470786cab3932"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2024-11",
    "cve": "CVE-2024-6232",
    "published": "2024-09-03T12:29:00.102000+00:00",
    "modified": "2025-01-31T19:54:59.572000+00:00",
    "severity": null,
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/121285",
      "issue_number": "121285"
    },
    "details": "There is a MEDIUM severity vulnerability affecting CPython.\n\n\n\n\n\nRegular expressions that allowed excessive backtracking during tarfile.TarFile header parsing are vulnerable to ReDoS via specifically-crafted tar archives.",
    "affected_versions": [
      [
        [
          3,
          8,
          0
        ],
        [
          3,
          8,
          19
        ]
      ],
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          19
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          14
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          9
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          5
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          8,
          20
        ],
        "commits": [
          "7d1f50cd92ff7e10a1c15a8f591dde8a6843a64d"
        ]
      },
      {
        "version": [
          3,
          9,
          20
        ],
        "commits": [
          "b4225ca91547aa97ed3aca391614afbb255bc877"
        ]
      },
      {
        "version": [
          3,
          10,
          15
        ],
        "commits": [
          "743acbe872485dc18df4d8ab2dc7895187f062c4"
        ]
      },
      {
        "version": [
          3,
          11,
          10
        ],
        "commits": [
          "d449caf8a179e3b954268b3a88eb9170be3c8fbf"
        ]
      },
      {
        "version": [
          3,
          12,
          6
        ],
        "commits": [
          "4eaf4891c12589e3c7bdad5f5b076e4c8392dd06"
        ]
      },
      {
        "version": [
          3,
          13,
          0
        ],
        "commits": [
          "ed3a49ea734ada357ff4442996fd4ae71d253373"
        ]
      },
      {
        "version": [
          3,
          14,
          0
        ],
        "commits": [
          "34ddb64d088dd7ccc321f6103d23153256caa5d4"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2024-12",
    "cve": "CVE-2024-9287",
    "published": "2024-10-22T16:34:39.210000+00:00",
    "modified": "2025-01-31T19:55:27.648000+00:00",
    "severity": {
      "name": "MEDIUM",
      "score": 5.3,
      "version": "4.0"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/124651",
      "issue_number": "124651"
    },
    "details": "A vulnerability has been found in the CPython `venv` module and CLI where path names provided when creating a virtual environment were not quoted properly, allowing the creator to inject commands into virtual environment \"activation\" scripts (ie \"source venv/bin/activate\"). This means that attacker-controlled virtual environments are able to run commands when the virtual environment is activated. Virtual environments which are not created by an attacker or which aren't activated before being used (ie \"./venv/bin/python\") are not affected.",
    "affected_versions": [
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          20
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          15
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          10
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          7
        ]
      ],
      [
        [
          3,
          13,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          9,
          21
        ],
        "commits": [
          "633555735a023d3e4d92ba31da35b1205f9ecbd7"
        ]
      },
      {
        "version": [
          3,
          10,
          16
        ],
        "commits": [
          "9286ab3a107ea41bd3f3c3682ce2512692bdded8"
        ]
      },
      {
        "version": [
          3,
          11,
          11
        ],
        "commits": [
          "ae961ae94bf19c8f8c7fbea3d1c25cc55ce8ae97"
        ]
      },
      {
        "version": [
          3,
          12,
          8
        ],
        "commits": [
          "8450b2482586857d689b6658f08de9c8179af7db"
        ]
      },
      {
        "version": [
          3,
          13,
          1
        ],
        "commits": [
          "e52095a0c1005a87eed2276af7a1f2f66e2b6483"
        ]
      },
      {
        "version": [
          3,
          14,
          0
        ],
        "commits": [
          "d48cc82ed25e26b02eb97c6263d95dcaa1e9111b"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2024-13",
    "cve": "CVE-2024-11168",
    "published": "2024-11-12T21:22:23.438000+00:00",
    "modified": "2024-12-03T20:29:59.700000+00:00",
    "severity": {
      "name": "MEDIUM",
      "score": 6.3,
      "version": "4.0"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/103848",
      "issue_number": "103848"
    },
    "details": "The urllib.parse.urlsplit() and urlparse() functions improperly validated bracketed hosts (`[]`), allowing hosts that weren't IPv6 or IPvFuture. This behavior was not conformant to RFC 3986 and potentially enabled SSRF if a URL is processed by more than one URL parser.",
    "affected_versions": [
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          20
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          15
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          9,
          21
        ],
        "commits": [
          "ddca2953191c67a12b1f19d6bca41016c6ae7132"
        ]
      },
      {
        "version": [
          3,
          10,
          16
        ],
        "commits": [
          "634ded45545ce8cbd6fd5d49785613dd7fa9b89e"
        ]
      },
      {
        "version": [
          3,
          11,
          4
        ],
        "commits": [
          "b2171a2fd41416cf68afd67460578631d755a550"
        ]
      },
      {
        "version": [
          3,
          12,
          0
        ],
        "commits": [
          "29f348e232e82938ba2165843c448c2b291504c5"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2024-14",
    "cve": "CVE-2024-12254",
    "published": "2024-12-06T15:19:41.576000+00:00",
    "modified": "2025-01-31T19:54:30.956000+00:00",
    "severity": {
      "name": "HIGH",
      "score": 8.7,
      "version": "4.0"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/127655",
      "issue_number": "127655"
    },
    "details": "Starting in Python 3.12.0, the asyncio._SelectorSocketTransport.writelines()\n method would not \"pause\" writing and signal to the Protocol to drain \nthe buffer to the wire once the write buffer reached the \"high-water \nmark\". Because of this, Protocols would not periodically drain the write\n buffer potentially leading to memory exhaustion.\n\n\n\n\n\nThis\n vulnerability likely impacts a small number of users, you must be using\n Python 3.12.0 or later, on macOS or Linux, using the asyncio module \nwith protocols, and using .writelines() method which had new \nzero-copy-on-write behavior in Python 3.12.0 and later. If not all of \nthese factors are true then your usage of Python is unaffected.",
    "affected_versions": [
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          8
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          1
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          12,
          9
        ],
        "commits": [
          "9aa0deb2eef2655a1029ba228527b152353135b5"
        ]
      },
      {
        "version": [
          3,
          13,
          2
        ],
        "commits": [
          "71e8429ac8e2adc10084ab5ec29a62f4b6671a82"
        ]
      },
      {
        "version": [
          3,
          14,
          0
        ],
        "commits": [
          "e991ac8f2037d78140e417cc9a9486223eb3e786"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2025-1",
    "cve": "CVE-2025-0938",
    "published": "2025-01-31T17:51:35.898000+00:00",
    "modified": "2025-02-28T19:10:34.555000+00:00",
    "severity": {
      "name": "MEDIUM",
      "score": 6.3,
      "version": "4.0"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/105704",
      "issue_number": "105704"
    },
    "details": "The Python standard library functions `urllib.parse.urlsplit` and `urlparse` accepted domain names that included square brackets which isn't valid according to RFC 3986. Square brackets are only meant to be used as delimiters for specifying IPv6 and IPvFuture hosts in URLs. This could result in differential parsing across the Python URL parser and other specification-compliant URL parsers.",
    "affected_versions": [
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          21
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          16
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          11
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          8
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          1
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          9,
          22
        ],
        "commits": [
          "ff4e5c25666f63544071a6b075ae8b25c98b7a32"
        ]
      },
      {
        "version": [
          3,
          10,
          17
        ],
        "commits": [
          "b8b4b713c5f8ec0958c7ef8d29d6711889bc94ab"
        ]
      },
      {
        "version": [
          3,
          11,
          12
        ],
        "commits": [
          "526617ed68cde460236c973e5d0a8bad4de896ba"
        ]
      },
      {
        "version": [
          3,
          12,
          9
        ],
        "commits": [
          "a7084f6075c9595ba60119ce8c62f1496f50c568"
        ]
      },
      {
        "version": [
          3,
          13,
          2
        ],
        "commits": [
          "90e526ae67b172ed7c6c56e7edad36263b0f9403"
        ]
      },
      {
        "version": [
          3,
          14,
          0
        ],
        "commits": [
          "d89a5f6a6e65511a5f6e0618c4c30a7aa5aba56a"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2025-2",
    "cve": "CVE-2024-3220",
    "published": "2025-02-14T16:18:00+00:00",
    "modified": "2025-02-14T19:02:38+00:00",
    "severity": {
      "name": "LOW",
      "score": 2.3,
      "version": "4.0"
    },
    "issue": null,
    "details": "There is a defect in the CPython standard library module \u201cmimetypes\u201d where on Windows the default list of known file locations are writable meaning other users can create invalid files to cause MemoryError to be raised on Python runtime startup or have file extensions be interpreted as the incorrect file type.\n\nThis defect is caused by the default locations of Linux and macOS platforms (such as \u201c/etc/mime.types\u201d) also being used on Windows, where they are user-writable locations (\u201cC:\\etc\\mime.types\u201d).\n\nTo work-around this issue a user can call mimetypes.init() with an empty list (\u201c[]\u201d) on Windows platforms to avoid using the default list of known file locations.",
    "affected_versions": [
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          25
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          19
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          14
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          12
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          11
        ]
      ]
    ],
    "fixed_in": [],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        9
      ],
      [
        3,
        10
      ],
      [
        3,
        11
      ],
      [
        3,
        12
      ],
      [
        3,
        13
      ]
    ]
  },
  {
    "id": "PSF-2025-3",
    "cve": "CVE-2025-1795",
    "published": "2025-02-28T18:59:31.784000+00:00",
    "modified": "2025-11-03T15:40:14.922000+00:00",
    "severity": {
      "name": "LOW",
      "score": 2.3,
      "version": "4.0"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/100884",
      "issue_number": "100884"
    },
    "details": "During an address list folding when a separating comma ends up on a folded line and that line is to be unicode-encoded then the separator itself is also unicode-encoded. Expected behavior is that the separating comma remains a plan comma. This can result in the address header being misinterpreted by some mail servers.",
    "affected_versions": [
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          22
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          16
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          8
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          2
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          9,
          23
        ],
        "commits": [
          "d4df3c55e4c5513947f907f24766b34d2ae8c090"
        ]
      },
      {
        "version": [
          3,
          10,
          17
        ],
        "commits": [
          "a4ef689ce670684ec132204b1cd03720c8e0a03d"
        ]
      },
      {
        "version": [
          3,
          11,
          9
        ],
        "commits": [
          "70754d21c288535e86070ca7a6e90dcb670b8593"
        ]
      },
      {
        "version": [
          3,
          12,
          3
        ],
        "commits": [
          "9148b77e0af91cdacaa7fe3dfac09635c3fe9a74"
        ]
      },
      {
        "version": [
          3,
          13,
          0
        ],
        "commits": [
          "09fab93c3d857496c0bd162797fab816c311ee48"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2025-4",
    "cve": "CVE-2025-4516",
    "published": "2025-05-15T13:29:20.126000+00:00",
    "modified": "2025-06-03T20:53:33.583000+00:00",
    "severity": {
      "name": "MEDIUM",
      "score": 5.9,
      "version": "4.0"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/133767",
      "issue_number": "133767"
    },
    "details": "There is an issue in CPython when using `bytes.decode(\"unicode_escape\", error=\"ignore|replace\")`. If you are not using the \"unicode_escape\" encoding or an error handler your usage is not affected. To work-around this issue you may stop using the error= handler and instead wrap the bytes.decode() call in a try-except catching the DecodeError.",
    "affected_versions": [
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          22
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          17
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          12
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          10
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          9,
          23
        ],
        "commits": [
          "8d35fd1b34935221aff23a1ab69a429dd156be77"
        ]
      },
      {
        "version": [
          3,
          10,
          18
        ],
        "commits": [
          "ab9893c40609935e0d40a6d2a7307ea51aec598b"
        ]
      },
      {
        "version": [
          3,
          11,
          13
        ],
        "commits": [
          "73b3040f592436385007918887b7e2132aa8431f"
        ]
      },
      {
        "version": [
          3,
          12,
          11
        ],
        "commits": [
          "4398b788ffc1f954a2c552da285477d42a571292"
        ]
      },
      {
        "version": [
          3,
          13,
          4
        ],
        "commits": [
          "6279eb8c076d89d3739a6edb393e43c7929b429d"
        ]
      },
      {
        "version": [
          3,
          14,
          0
        ],
        "commits": [
          "69b4387f78f413e8c47572a85b3478c47eba8142"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2025-5",
    "cve": "CVE-2024-12718",
    "published": "2025-06-03T12:59:10+00:00",
    "modified": "2025-06-03T20:55:06+00:00",
    "severity": {
      "name": "MEDIUM",
      "score": 5.3,
      "version": "3.1"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/135034",
      "issue_number": "135034"
    },
    "details": "Allows modifying some file metadata (e.g. last modified) with filter=\"data\"\u00a0or file permissions (chmod) with filter=\"tar\"\u00a0of files outside the extraction directory.\nYou are affected by this vulnerability if using the tarfile\u00a0module to extract untrusted tar archives using TarFile.extractall()\u00a0or TarFile.extract()\u00a0using the filter=\u00a0parameter with a value of \"data\"\u00a0or \"tar\". See the tarfile  extraction filters documentation https://docs.python.org/3/library/tarfile.html#tarfile-extraction-filter \u00a0for more information. Only Python versions 3.12 or later are affected by these vulnerabilities, earlier versions don't include the extraction filter feature.\n\nNote that for Python 3.14 or later the default value of filter=\u00a0changed from \"no filtering\" to `\"data\", so if you are relying on this new default behavior then your usage is also affected.\n\nNote that none of these vulnerabilities significantly affect the installation of source distributions which are tar archives as source distributions already allow arbitrary code execution during the build process. However when evaluating source distributions it's important to avoid installing source distributions with suspicious links.",
    "affected_versions": [
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          22
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          17
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          12
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          10
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          9,
          23
        ],
        "commits": [
          "dd8f187d0746da151e0025c51680979ac5b4cfb1"
        ]
      },
      {
        "version": [
          3,
          10,
          18
        ],
        "commits": [
          "9c1110ef6652687d7c55f590f909720eddde965a"
        ]
      },
      {
        "version": [
          3,
          11,
          13
        ],
        "commits": [
          "4633f3f497b1ff70e4a35b6fe2c907cbe2d4cb2e"
        ]
      },
      {
        "version": [
          3,
          12,
          11
        ],
        "commits": [
          "19de092debb3d7e832e5672cc2f7b788d35951da",
          "28463dba112af719df1e8b0391c46787ad756dd9"
        ]
      },
      {
        "version": [
          3,
          13,
          4
        ],
        "commits": [
          "aa9eb5f757ceff461e6e996f12c89e5d9b583b01"
        ]
      },
      {
        "version": [
          3,
          14,
          0
        ],
        "commits": [
          "9e0ac76d96cf80b49055f6d6b9a6763fb9215c2a"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2025-6",
    "cve": "CVE-2025-4138",
    "published": "2025-06-03T12:59:02.717000+00:00",
    "modified": "2025-06-05T14:01:24.309000+00:00",
    "severity": {
      "name": "HIGH",
      "score": 7.5,
      "version": "3.1"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/135034",
      "issue_number": "135034"
    },
    "details": "Allows the extraction filter to be ignored, allowing symlink targets to point outside the destination directory, and the modification of some file metadata.\n\n\nYou are affected by this vulnerability if using the tarfile\u00a0module to extract untrusted tar archives using TarFile.extractall()\u00a0or TarFile.extract()\u00a0using the filter=\u00a0parameter with a value of \"data\"\u00a0or \"tar\". See the tarfile  extraction filters documentation https://docs.python.org/3/library/tarfile.html#tarfile-extraction-filter \u00a0for more information.\n\nNote that for Python 3.14 or later the default value of filter=\u00a0changed from \"no filtering\" to `\"data\", so if you are relying on this new default behavior then your usage is also affected.\n\nNote that none of these vulnerabilities significantly affect the installation of source distributions which are tar archives as source distributions already allow arbitrary code execution during the build process. However when evaluating source distributions it's important to avoid installing source distributions with suspicious links.",
    "affected_versions": [
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          22
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          17
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          12
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          10
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          9,
          23
        ],
        "commits": [
          "dd8f187d0746da151e0025c51680979ac5b4cfb1"
        ]
      },
      {
        "version": [
          3,
          10,
          18
        ],
        "commits": [
          "9c1110ef6652687d7c55f590f909720eddde965a"
        ]
      },
      {
        "version": [
          3,
          11,
          13
        ],
        "commits": [
          "4633f3f497b1ff70e4a35b6fe2c907cbe2d4cb2e"
        ]
      },
      {
        "version": [
          3,
          12,
          11
        ],
        "commits": [
          "19de092debb3d7e832e5672cc2f7b788d35951da",
          "28463dba112af719df1e8b0391c46787ad756dd9"
        ]
      },
      {
        "version": [
          3,
          13,
          4
        ],
        "commits": [
          "aa9eb5f757ceff461e6e996f12c89e5d9b583b01"
        ]
      },
      {
        "version": [
          3,
          14,
          0
        ],
        "commits": [
          "9e0ac76d96cf80b49055f6d6b9a6763fb9215c2a"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2025-7",
    "cve": "CVE-2025-4330",
    "published": "2025-06-03T12:58:57.452000+00:00",
    "modified": "2025-06-05T14:16:14.362000+00:00",
    "severity": {
      "name": "HIGH",
      "score": 7.5,
      "version": "3.1"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/135034",
      "issue_number": "135034"
    },
    "details": "Allows the extraction filter to be ignored, allowing symlink targets to point outside the destination directory, and the modification of some file metadata.\n\n\nYou are affected by this vulnerability if using the tarfile\u00a0module to extract untrusted tar archives using TarFile.extractall()\u00a0or TarFile.extract()\u00a0using the filter=\u00a0parameter with a value of \"data\"\u00a0or \"tar\". See the tarfile  extraction filters documentation https://docs.python.org/3/library/tarfile.html#tarfile-extraction-filter \u00a0for more information.\n\nNote that for Python 3.14 or later the default value of filter=\u00a0changed from \"no filtering\" to `\"data\", so if you are relying on this new default behavior then your usage is also affected.\n\nNote that none of these vulnerabilities significantly affect the installation of source distributions which are tar archives as source distributions already allow arbitrary code execution during the build process. However when evaluating source distributions it's important to avoid installing source distributions with suspicious links.",
    "affected_versions": [
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          22
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          17
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          12
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          10
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          9,
          23
        ],
        "commits": [
          "dd8f187d0746da151e0025c51680979ac5b4cfb1"
        ]
      },
      {
        "version": [
          3,
          10,
          18
        ],
        "commits": [
          "9c1110ef6652687d7c55f590f909720eddde965a"
        ]
      },
      {
        "version": [
          3,
          11,
          13
        ],
        "commits": [
          "4633f3f497b1ff70e4a35b6fe2c907cbe2d4cb2e"
        ]
      },
      {
        "version": [
          3,
          12,
          11
        ],
        "commits": [
          "19de092debb3d7e832e5672cc2f7b788d35951da",
          "28463dba112af719df1e8b0391c46787ad756dd9"
        ]
      },
      {
        "version": [
          3,
          13,
          4
        ],
        "commits": [
          "aa9eb5f757ceff461e6e996f12c89e5d9b583b01"
        ]
      },
      {
        "version": [
          3,
          14,
          0
        ],
        "commits": [
          "9e0ac76d96cf80b49055f6d6b9a6763fb9215c2a"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2025-8",
    "cve": "CVE-2025-4435",
    "published": "2025-06-03T12:59:06+00:00",
    "modified": "2025-06-03T20:53:26+00:00",
    "severity": {
      "name": "HIGH",
      "score": 7.5,
      "version": "3.1"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/135034",
      "issue_number": "135034"
    },
    "details": "When using a TarFile.errorlevel = 0\u00a0and extracting with a filter the documented behavior is that any filtered members would be skipped and not extracted. However the actual behavior of TarFile.errorlevel = 0\u00a0in affected versions is that the member would still be extracted and not skipped.",
    "affected_versions": [
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          22
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          17
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          12
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          10
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          9,
          23
        ],
        "commits": [
          "dd8f187d0746da151e0025c51680979ac5b4cfb1"
        ]
      },
      {
        "version": [
          3,
          10,
          18
        ],
        "commits": [
          "9c1110ef6652687d7c55f590f909720eddde965a"
        ]
      },
      {
        "version": [
          3,
          11,
          13
        ],
        "commits": [
          "4633f3f497b1ff70e4a35b6fe2c907cbe2d4cb2e"
        ]
      },
      {
        "version": [
          3,
          12,
          11
        ],
        "commits": [
          "19de092debb3d7e832e5672cc2f7b788d35951da",
          "28463dba112af719df1e8b0391c46787ad756dd9"
        ]
      },
      {
        "version": [
          3,
          13,
          4
        ],
        "commits": [
          "aa9eb5f757ceff461e6e996f12c89e5d9b583b01"
        ]
      },
      {
        "version": [
          3,
          14,
          0
        ],
        "commits": [
          "9e0ac76d96cf80b49055f6d6b9a6763fb9215c2a"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2025-9",
    "cve": "CVE-2025-4517",
    "published": "2025-06-03T12:58:50.352000+00:00",
    "modified": "2025-06-05T14:17:17.111000+00:00",
    "severity": {
      "name": "CRITICAL",
      "score": 9.4,
      "version": "3.1"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/135034",
      "issue_number": "135034"
    },
    "details": "Allows arbitrary filesystem writes outside the extraction directory during extraction with filter=\"data\".\n\n\nYou are affected by this vulnerability if using the tarfile\u00a0module to extract untrusted tar archives using TarFile.extractall()\u00a0or TarFile.extract()\u00a0using the filter=\u00a0parameter with a value of \"data\"\u00a0or \"tar\". See the tarfile  extraction filters documentation https://docs.python.org/3/library/tarfile.html#tarfile-extraction-filter \u00a0for more information.\n\nNote that for Python 3.14 or later the default value of filter=\u00a0changed from \"no filtering\" to `\"data\", so if you are relying on this new default behavior then your usage is also affected.\n\nNote that none of these vulnerabilities significantly affect the installation of source distributions which are tar archives as source distributions already allow arbitrary code execution during the build process. However when evaluating source distributions it's important to avoid installing source distributions with suspicious links.",
    "affected_versions": [
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          22
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          17
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          12
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          10
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          3
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          9,
          23
        ],
        "commits": [
          "dd8f187d0746da151e0025c51680979ac5b4cfb1"
        ]
      },
      {
        "version": [
          3,
          10,
          18
        ],
        "commits": [
          "9c1110ef6652687d7c55f590f909720eddde965a"
        ]
      },
      {
        "version": [
          3,
          11,
          13
        ],
        "commits": [
          "4633f3f497b1ff70e4a35b6fe2c907cbe2d4cb2e"
        ]
      },
      {
        "version": [
          3,
          12,
          11
        ],
        "commits": [
          "19de092debb3d7e832e5672cc2f7b788d35951da",
          "28463dba112af719df1e8b0391c46787ad756dd9"
        ]
      },
      {
        "version": [
          3,
          13,
          4
        ],
        "commits": [
          "aa9eb5f757ceff461e6e996f12c89e5d9b583b01"
        ]
      },
      {
        "version": [
          3,
          14,
          0
        ],
        "commits": [
          "9e0ac76d96cf80b49055f6d6b9a6763fb9215c2a"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2025-10",
    "cve": "CVE-2025-6069",
    "published": "2025-06-17T13:39:46+00:00",
    "modified": "2025-07-07T17:36:31+00:00",
    "severity": {
      "name": "MEDIUM",
      "score": 4.3,
      "version": "3.1"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/135462",
      "issue_number": "135462"
    },
    "details": "The html.parser.HTMLParser class had worse-case quadratic complexity when processing certain crafted malformed inputs potentially leading to amplified denial-of-service.",
    "affected_versions": [
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          23
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          18
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          13
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          11
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          5
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          9,
          24
        ],
        "commits": [
          "8d1b3dfa09135affbbf27fb8babcf3c11415df49"
        ]
      },
      {
        "version": [
          3,
          10,
          19
        ],
        "commits": [
          "fdc9d214c01cb4588f540cfa03726bbf2a33fc15"
        ]
      },
      {
        "version": [
          3,
          11,
          14
        ],
        "commits": [
          "f3c6f882cddc8dc30320d2e73edf019e201394fc"
        ]
      },
      {
        "version": [
          3,
          12,
          12
        ],
        "commits": [
          "ab0893fd5c579d9cea30841680e6d35fc478afb5"
        ]
      },
      {
        "version": [
          3,
          13,
          6
        ],
        "commits": [
          "4455cbabf991e202185a25a631af206f60bbc949"
        ]
      },
      {
        "version": [
          3,
          14,
          0
        ],
        "commits": [
          "d851f8e258c7328814943e923a7df81bca15df4b"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2025-11",
    "cve": "CVE-2025-8194",
    "published": "2025-07-28T18:42:44.847000+00:00",
    "modified": "2025-09-24T17:50:54.554000+00:00",
    "severity": {
      "name": "HIGH",
      "score": 7.5,
      "version": "3.1"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/130577",
      "issue_number": "130577"
    },
    "details": "There is a defect in the CPython \u201ctarfile\u201d module affecting the \u201cTarFile\u201d extraction and entry enumeration APIs. The tar implementation would process tar archives with negative offsets without error, resulting in an infinite loop and deadlock during the parsing of maliciously crafted tar archives. \n\nThis vulnerability can be mitigated by including the following patch after importing the \u201ctarfile\u201d module:\u00a0 https://gist.github.com/sethmlarson/1716ac5b82b73dbcbf23ad2eff8b33e1",
    "affected_versions": [
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          23
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          18
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          13
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          11
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          5
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          9,
          24
        ],
        "commits": [
          "73f03e4808206f71eb6b92c579505a220942ef19"
        ]
      },
      {
        "version": [
          3,
          10,
          19
        ],
        "commits": [
          "57f5981d6260ed21266e0c26951b8564cc252bc2"
        ]
      },
      {
        "version": [
          3,
          11,
          14
        ],
        "commits": [
          "b4ec17488eedec36d3c05fec127df71c0071f6cb"
        ]
      },
      {
        "version": [
          3,
          12,
          12
        ],
        "commits": [
          "c9d9f78feb1467e73fd29356c040bde1c104f29f"
        ]
      },
      {
        "version": [
          3,
          13,
          6
        ],
        "commits": [
          "cdae923ffe187d6ef916c0f665a31249619193fe"
        ]
      },
      {
        "version": [
          3,
          14,
          0
        ],
        "commits": [
          "fbc2a0ca9ac8aff6887f8ddf79b87b4510277227"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2025-12",
    "cve": "CVE-2025-8291",
    "published": "2025-10-07T18:10:05.908000+00:00",
    "modified": "2025-10-09T18:38:08.294000+00:00",
    "severity": {
      "name": "MEDIUM",
      "score": 4.3,
      "version": "3.1"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/139700",
      "issue_number": "139700"
    },
    "details": "The 'zipfile' module would not check the validity of the ZIP64 End of\nCentral Directory (EOCD) Locator record offset value would not be used to\nlocate the ZIP64 EOCD record, instead the ZIP64 EOCD record would be\nassumed to be the previous record in the ZIP archive. This could be abused\nto create ZIP archives that are handled differently by the 'zipfile' module\ncompared to other ZIP implementations.\n\n\nRemediation maintains this behavior, but checks that the offset specified\nin the ZIP64 EOCD Locator record matches the expected value.",
    "affected_versions": [
      [
        [
          3,
          9,
          0
        ],
        [
          3,
          9,
          23
        ]
      ],
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          18
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          13
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          11
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          9
        ]
      ],
      [
        [
          3,
          14,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          9,
          24
        ],
        "commits": [
          "76437ac248ad8ca44e9bf697b02b1e2241df2196"
        ]
      },
      {
        "version": [
          3,
          10,
          19
        ],
        "commits": [
          "bca11ae7d575d87ed93f5dd6a313be6246e3e388"
        ]
      },
      {
        "version": [
          3,
          11,
          14
        ],
        "commits": [
          "1d29afb0d6218aa8fb5e1e4a6133a4778d89bb46"
        ]
      },
      {
        "version": [
          3,
          12,
          12
        ],
        "commits": [
          "8392b2f0d35678407d9ce7d95655a5b77de161b4"
        ]
      },
      {
        "version": [
          3,
          13,
          9
        ],
        "commits": [
          "333d4a6f4967d3ace91492a39ededbcf3faa76a6"
        ]
      },
      {
        "version": [
          3,
          14,
          1
        ],
        "commits": [
          "d11e69d6203080e3ec450446bfed0516727b85c3"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": []
  },
  {
    "id": "PSF-2025-13",
    "cve": "CVE-2025-6075",
    "published": "2025-10-31T16:41:34.983000+00:00",
    "modified": "2025-12-01T19:01:43.132000+00:00",
    "severity": {
      "name": "LOW",
      "score": 1.8,
      "version": "4.0"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/136065",
      "issue_number": "136065"
    },
    "details": "If the value passed to os.path.expandvars() is user-controlled a \nperformance degradation is possible when expanding environment \nvariables.",
    "affected_versions": [
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          19
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          14
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          12
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          9
        ]
      ],
      [
        [
          3,
          14,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          9,
          25
        ],
        "commits": [
          "2e6150adccaaf5bd95d4c19dfd04a36e0b325d8c"
        ]
      },
      {
        "version": [
          3,
          13,
          10
        ],
        "commits": [
          "9ab89c026aa9611c4b0b67c288b8303a480fe742"
        ]
      },
      {
        "version": [
          3,
          14,
          1
        ],
        "commits": [
          "631ba3407e3348ccd56ce5160c4fb2c5dc5f4d84"
        ]
      }
    ],
    "fixed_but_not_released": [
      {
        "branch": [
          3,
          10
        ],
        "commit": "892747b4cf0f95ba8beb51c0d0658bfaa381ebca"
      },
      {
        "branch": [
          3,
          11
        ],
        "commit": "5dceb93486176e6b4a6d9754491005113eb23427"
      },
      {
        "branch": [
          3,
          12
        ],
        "commit": "c8a5f3435c342964e0a432cc9fb448b7dbecd1ba"
      }
    ],
    "fixes_pending": []
  },
  {
    "id": "PSF-2025-14",
    "cve": "CVE-2025-13836",
    "published": "2025-12-01T18:02:38.483000+00:00",
    "modified": "2026-01-26T14:18:39.099000+00:00",
    "severity": {
      "name": "MEDIUM",
      "score": 6.3,
      "version": "4.0"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/119451",
      "issue_number": "119451"
    },
    "details": "When reading an HTTP response from a server, if no read amount is specified, the default behavior will be to use Content-Length. This allows a malicious server to cause the client to read large amounts of data into memory, potentially causing OOM or other DoS.",
    "affected_versions": [
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          19
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          14
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          12
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          10
        ]
      ],
      [
        [
          3,
          14,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          13,
          11
        ],
        "commits": [
          "289f29b0fe38baf2d7cb5854f4bb573cc34a6a15"
        ]
      },
      {
        "version": [
          3,
          14,
          1
        ],
        "commits": [
          "4ce27904b597c77d74dd93f2c912676021a99155"
        ]
      }
    ],
    "fixed_but_not_released": [
      {
        "branch": [
          3,
          10
        ],
        "commit": "5dc101675fd22918facbbe0fecdc821502beaaf0"
      },
      {
        "branch": [
          3,
          11
        ],
        "commit": "afc40bdd3dd71f343fd9016f6d8eebbacbd6587c"
      },
      {
        "branch": [
          3,
          12
        ],
        "commit": "14b1fdb0a94b96f86fc7b86671ea9582b8676628"
      }
    ],
    "fixes_pending": []
  },
  {
    "id": "PSF-2025-15",
    "cve": "CVE-2025-13837",
    "published": "2025-12-01T18:13:32.739000+00:00",
    "modified": "2025-12-22T20:03:50.389000+00:00",
    "severity": {
      "name": "LOW",
      "score": 2.1,
      "version": "4.0"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/119342",
      "issue_number": "119342"
    },
    "details": "When loading a plist file, the plistlib module reads data in size specified by the file itself, meaning a malicious file can cause OOM and DoS issues",
    "affected_versions": [
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          19
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          14
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          12
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          9
        ]
      ],
      [
        [
          3,
          14,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          13,
          10
        ],
        "commits": [
          "71fa8eb8233b37f16c88b6e3e583b461b205d1ba"
        ]
      },
      {
        "version": [
          3,
          14,
          1
        ],
        "commits": [
          "b64441e4852383645af5b435411a6f849dd1b4cb"
        ]
      }
    ],
    "fixed_but_not_released": [
      {
        "branch": [
          3,
          12
        ],
        "commit": "5a8b19677d818fb41ee55f310233772e15aa1a2b"
      }
    ],
    "fixes_pending": [
      [
        3,
        10
      ],
      [
        3,
        11
      ]
    ]
  },
  {
    "id": "PSF-2025-16",
    "cve": "CVE-2025-12084",
    "published": "2025-12-03T18:55:32.222000+00:00",
    "modified": "2026-01-26T14:18:29.104000+00:00",
    "severity": {
      "name": "MEDIUM",
      "score": 6.3,
      "version": "4.0"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/142145",
      "issue_number": "142145"
    },
    "details": "When building nested elements using xml.dom.minidom methods such as appendChild() that have a dependency on _clear_id_cache() the algorithm is quadratic. Availability can be impacted when building excessively nested documents.",
    "affected_versions": [
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          19
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          14
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          12
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          10
        ]
      ],
      [
        [
          3,
          14,
          0
        ],
        [
          3,
          14,
          1
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          13,
          11
        ],
        "commits": [
          "ddcd2acd85d891a53e281c773b3093f9db953964"
        ]
      },
      {
        "version": [
          3,
          14,
          2
        ],
        "commits": [
          "027f21e417b26eed4505ac2db101a4352b7c51a0"
        ]
      }
    ],
    "fixed_but_not_released": [
      {
        "branch": [
          3,
          10
        ],
        "commit": "c97e87593063d84a2bd9fe7068b30eb44de23dc0"
      },
      {
        "branch": [
          3,
          11
        ],
        "commit": "a46c10ec9d4050ab67b8a932e0859a2ea60c3cb8"
      },
      {
        "branch": [
          3,
          12
        ],
        "commit": "9c9dda6625a2a90d2a06c657eee021d6be19842d"
      },
      {
        "branch": [
          3,
          13
        ],
        "commit": "a696ba8b4d42fd632afc9bc88ad830a2e4cceed8"
      },
      {
        "branch": [
          3,
          13
        ],
        "commit": "e91c11449cad34bac3ea55ee09ca557691d92b53"
      },
      {
        "branch": [
          3,
          14
        ],
        "commit": "41f468786762348960486c166833a218a0a436af"
      },
      {
        "branch": [
          3,
          14
        ],
        "commit": "27648a1818749ef44c420afe6173af6868715437"
      }
    ],
    "fixes_pending": []
  },
  {
    "id": "PSF-2026-1",
    "cve": "CVE-2025-11468",
    "published": "2026-01-20T21:09:11.229000+00:00",
    "modified": "2026-02-02T21:56:06.614000+00:00",
    "severity": {
      "name": "MEDIUM",
      "score": 5.7,
      "version": "4.0"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/143935",
      "issue_number": "143935"
    },
    "details": "When folding a long comment in an email header containing exclusively unfoldable characters, the parenthesis would not be preserved. This could be used for injecting headers into email messages where addresses are user-controlled and not sanitized.",
    "affected_versions": [
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          19
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          14
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          12
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          11
        ]
      ],
      [
        [
          3,
          14,
          0
        ],
        [
          3,
          14,
          2
        ]
      ]
    ],
    "fixed_in": [],
    "fixed_but_not_released": [
      {
        "branch": [
          3,
          11
        ],
        "commit": "e9970f077240c7c670e8a6fc6662f2b30d3b6ad0"
      },
      {
        "branch": [
          3,
          12
        ],
        "commit": "a76e4cd62dd68e7cbe86e37e6ed988495a646b66"
      },
      {
        "branch": [
          3,
          13
        ],
        "commit": "f738386838021c762efea6c9802c82de65e87796"
      },
      {
        "branch": [
          3,
          14
        ],
        "commit": "61614a5e5056e4f61ced65008d4576f3df34acb6"
      }
    ],
    "fixes_pending": [
      [
        3,
        10
      ]
    ]
  },
  {
    "id": "PSF-2026-2",
    "cve": "CVE-2025-15282",
    "published": "2026-01-20T21:35:13.865000+00:00",
    "modified": "2026-01-26T14:18:51.450000+00:00",
    "severity": {
      "name": "MEDIUM",
      "score": 6,
      "version": "4.0"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/143925",
      "issue_number": "143925"
    },
    "details": "User-controlled data URLs parsed by urllib.request.DataHandler allow injecting headers through newlines in the data URL mediatype.",
    "affected_versions": [
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          19
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          14
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          12
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          11
        ]
      ],
      [
        [
          3,
          14,
          0
        ],
        [
          3,
          14,
          2
        ]
      ]
    ],
    "fixed_in": [],
    "fixed_but_not_released": [
      {
        "branch": [
          3,
          10
        ],
        "commit": "34d76b00dabde81a793bd06dd8ecb057838c4b38"
      },
      {
        "branch": [
          3,
          11
        ],
        "commit": "3f396ca9d7bbe2a50ea6b8c9b27c0082884d9f80"
      },
      {
        "branch": [
          3,
          12
        ],
        "commit": "4ed11d3cd288e6b90196a15c5a825a45d318fe47"
      },
      {
        "branch": [
          3,
          13
        ],
        "commit": "a35ca3be5842505dab74dc0b90b89cde0405017a"
      },
      {
        "branch": [
          3,
          14
        ],
        "commit": "05356b1cc153108aaf27f3b72ce438af4aa218c0"
      }
    ],
    "fixes_pending": []
  },
  {
    "id": "PSF-2026-3",
    "cve": "CVE-2025-15366",
    "published": "2026-01-20T21:40:24+00:00",
    "modified": "2026-01-20T22:27:50+00:00",
    "severity": {
      "name": "MEDIUM",
      "score": 5.9,
      "version": "4.0"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/143921",
      "issue_number": "143921"
    },
    "details": "The imaplib module, when passed a user-controlled command, can have additional commands injected using newlines. Mitigation rejects commands containing control characters.",
    "affected_versions": [
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          19
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          14
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          12
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          11
        ]
      ],
      [
        [
          3,
          14,
          0
        ],
        [
          3,
          14,
          2
        ]
      ]
    ],
    "fixed_in": [],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        10
      ],
      [
        3,
        11
      ],
      [
        3,
        12
      ],
      [
        3,
        13
      ],
      [
        3,
        14
      ]
    ]
  },
  {
    "id": "PSF-2026-4",
    "cve": "CVE-2025-15367",
    "published": "2026-01-20T21:47:09+00:00",
    "modified": "2026-01-20T22:27:52+00:00",
    "severity": {
      "name": "MEDIUM",
      "score": 5.9,
      "version": "4.0"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/143923",
      "issue_number": "143923"
    },
    "details": "The poplib module, when passed a user-controlled command, can have\nadditional commands injected using newlines. Mitigation rejects commands\ncontaining control characters.",
    "affected_versions": [
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          19
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          14
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          12
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          11
        ]
      ],
      [
        [
          3,
          14,
          0
        ],
        [
          3,
          14,
          2
        ]
      ]
    ],
    "fixed_in": [],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        10
      ],
      [
        3,
        11
      ],
      [
        3,
        12
      ],
      [
        3,
        13
      ],
      [
        3,
        14
      ]
    ]
  },
  {
    "id": "PSF-2026-5",
    "cve": "CVE-2026-0672",
    "published": "2026-01-20T21:52:33.925000+00:00",
    "modified": "2026-01-26T14:20:10.421000+00:00",
    "severity": {
      "name": "MEDIUM",
      "score": 6,
      "version": "4.0"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/143919",
      "issue_number": "143919"
    },
    "details": "When using http.cookies.Morsel, user-controlled cookie values and parameters can allow injecting HTTP headers into messages. Patch rejects all control characters within cookie names, values, and parameters.",
    "affected_versions": [
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          19
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          14
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          12
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          11
        ]
      ],
      [
        [
          3,
          14,
          0
        ],
        [
          3,
          14,
          2
        ]
      ]
    ],
    "fixed_in": [],
    "fixed_but_not_released": [
      {
        "branch": [
          3,
          10
        ],
        "commit": "7852d72b653fea0199acf5fc2a84f6f8b84eba8d"
      },
      {
        "branch": [
          3,
          11
        ],
        "commit": "b1869ff648bbee0717221d09e6deff46617f3e85"
      },
      {
        "branch": [
          3,
          12
        ],
        "commit": "62700107418eb2cca3fc88da036a243ea975f172"
      },
      {
        "branch": [
          3,
          13
        ],
        "commit": "918387e4912d12ffc166c8f2a38df92b6ec756ca"
      },
      {
        "branch": [
          3,
          14
        ],
        "commit": "712452e6f1d4b9f7f8c4c92ebfcaac1705faa440"
      }
    ],
    "fixes_pending": []
  },
  {
    "id": "PSF-2026-6",
    "cve": "CVE-2026-0865",
    "published": "2026-01-20T21:26:15+00:00",
    "modified": "2026-01-20T22:58:10+00:00",
    "severity": {
      "name": "MEDIUM",
      "score": 5.9,
      "version": "4.0"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/143916",
      "issue_number": "143916"
    },
    "details": "User-controlled header names and values containing newlines can allow injecting HTTP headers.",
    "affected_versions": [
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          19
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          14
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          12
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          11
        ]
      ],
      [
        [
          3,
          14,
          0
        ],
        [
          3,
          14,
          2
        ]
      ]
    ],
    "fixed_in": [],
    "fixed_but_not_released": [
      {
        "branch": [
          3,
          10
        ],
        "commit": "2f840249550e082dc351743f474ba56da10478d2"
      },
      {
        "branch": [
          3,
          11
        ],
        "commit": "e4846a93ac07a8ae9aa18203af0dd13d6e7a6995"
      },
      {
        "branch": [
          3,
          12
        ],
        "commit": "4802b96a2cde58570c24c13ef3289490980961c5"
      },
      {
        "branch": [
          3,
          13
        ],
        "commit": "22e4d55285cee52bc4dbe061324e5f30bd4dee58"
      },
      {
        "branch": [
          3,
          14
        ],
        "commit": "23e3c0ae867cca0130e441e776c9955b9027c510"
      }
    ],
    "fixes_pending": []
  },
  {
    "id": "PSF-2026-7",
    "cve": "CVE-2025-12781",
    "published": "2026-01-21T19:34:47.979000+00:00",
    "modified": "2026-01-22T20:12:56.421000+00:00",
    "severity": {
      "name": "MEDIUM",
      "score": 6.3,
      "version": "4.0"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/125346",
      "issue_number": "125346"
    },
    "details": "When passing data to the b64decode(), standard_b64decode(), and urlsafe_b64decode() functions in the \"base64\" module the characters \"+/\" will always be accepted, regardless of the value of \"altchars\" parameter, typically used to establish an \"alternative base64 alphabet\" such as the URL safe alphabet. This behavior matches what is recommended in earlier base64 RFCs, but newer RFCs now recommend either dropping characters outside the specified base64 alphabet or raising an error. The old behavior has the possibility of causing data integrity issues.\n\n\n\n\nThis behavior can only be insecure if your application uses an alternate base64 alphabet (without \"+/\"). If your application does not use the \"altchars\" parameter or the urlsafe_b64decode() function, then your application does not use an alternative base64 alphabet.\n\n\n\n\nThe attached patches DOES NOT make the base64-decode behavior raise an error, as this would be a change in behavior and break existing programs. Instead, the patch deprecates the behavior which will be replaced with the newly recommended behavior in a future version of Python.\u00a0Users are recommended to mitigate by verifying user-controlled inputs match the base64 \nalphabet they are expecting or verify that their application would not be \naffected if the b64decode() functions accepted \"+\" or \"/\" outside of altchars.",
    "affected_versions": [
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          19
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          14
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          12
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          9
        ]
      ],
      [
        [
          3,
          14,
          0
        ]
      ]
    ],
    "fixed_in": [
      {
        "version": [
          3,
          13,
          10
        ],
        "commits": [
          "1be80bec7960f5ccd059e75f3dfbd45fca302947"
        ]
      },
      {
        "version": [
          3,
          14,
          1
        ],
        "commits": [
          "fd17ee026fa9b67f6288cbafe374a3e479fe03a5"
        ]
      }
    ],
    "fixed_but_not_released": [],
    "fixes_pending": [
      [
        3,
        10
      ],
      [
        3,
        11
      ],
      [
        3,
        12
      ]
    ]
  },
  {
    "id": "PSF-2026-8",
    "cve": "CVE-2026-1299",
    "published": "2026-01-23T16:27:13.346000+00:00",
    "modified": "2026-01-26T14:20:21.976000+00:00",
    "severity": {
      "name": "MEDIUM",
      "score": 6,
      "version": "4.0"
    },
    "issue": {
      "type": "github",
      "url": "https://github.com/python/cpython/issues/144125",
      "issue_number": "144125"
    },
    "details": "The \nemail module, specifically the \"BytesGenerator\" class, didn\u2019t properly quote newlines for email headers when \nserializing an email message allowing for header injection when an email\n is serialized. This is only applicable if using \"LiteralHeader\" writing headers that don't respect email folding rules, the new behavior will reject the incorrectly folded headers in \"BytesGenerator\".",
    "affected_versions": [
      [
        [
          3,
          10,
          0
        ],
        [
          3,
          10,
          19
        ]
      ],
      [
        [
          3,
          11,
          0
        ],
        [
          3,
          11,
          14
        ]
      ],
      [
        [
          3,
          12,
          0
        ],
        [
          3,
          12,
          12
        ]
      ],
      [
        [
          3,
          13,
          0
        ],
        [
          3,
          13,
          11
        ]
      ],
      [
        [
          3,
          14,
          0
        ],
        [
          3,
          14,
          2
        ]
      ]
    ],
    "fixed_in": [],
    "fixed_but_not_released": [
      {
        "branch": [
          3,
          10
        ],
        "commit": "8cdf6204f4ae821f32993f8fc6bad0d318f95f36"
      },
      {
        "branch": [
          3,
          11
        ],
        "commit": "842ce19a0c0b58d61591e8f6a708c38db1fb94e4"
      },
      {
        "branch": [
          3,
          13
        ],
        "commit": "0a925ab591c45d6638f37b5e57796f36fa0e56d8"
      },
      {
        "branch": [
          3,
          14
        ],
        "commit": "7877fe424415bc4a13045e62a90a7277413d8cb9"
      }
    ],
    "fixes_pending": [
      [
        3,
        12
      ]
    ]
  }
]